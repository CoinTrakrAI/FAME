#!/usr/bin/env python3
"""
FAME Question Handler - Allows FAME to read and answer questions independently
"""

import os
import re
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, Optional

class FAMEQuestionHandler:
    """Handles question reading and answer generation for FAME"""
    
    def __init__(self, workspace_path: str = None):
        self.workspace_path = Path(workspace_path) if workspace_path else Path(__file__).parent
        self.question_files = []
        self.answer_files = []
        
    def find_unanswered_questions(self) -> list:
        """Find all question files without corresponding answers"""
        unanswered = []
        
        # Find all QUESTION_*.md files
        question_pattern = re.compile(r'^QUESTION_(\d+)\.md$')
        
        for file in self.workspace_path.glob('QUESTION_*.md'):
            match = question_pattern.match(file.name)
            if match:
                question_num = match.group(1)
                answer_file = self.workspace_path / f'QUESTION_{question_num}_ANSWER.md'
                
                if not answer_file.exists():
                    unanswered.append({
                        'question_file': file,
                        'question_number': question_num,
                        'answer_file': answer_file
                    })
        
        return unanswered
    
    def read_question_file(self, question_file: Path) -> Dict[str, Any]:
        """Read and parse a question file"""
        content = question_file.read_text(encoding='utf-8')
        
        # Extract question metadata
        question_data = {
            'file_path': str(question_file),
            'content': content,
            'question_number': None,
            'title': None,
            'query': None,
            'context': None
        }
        
        # Extract question number from filename
        match = re.search(r'QUESTION_(\d+)', question_file.name)
        if match:
            question_data['question_number'] = match.group(1)
        
        # Extract title
        title_match = re.search(r'^#\s+(.+)$', content, re.MULTILINE)
        if title_match:
            question_data['title'] = title_match.group(1)
        
        # Extract query section
        query_match = re.search(r'##\s+Question:?\s*\n\n(.+?)(?=\n##|\Z)', content, re.DOTALL)
        if query_match:
            question_data['query'] = query_match.group(1).strip()
        
        # Extract context (everything before Question section)
        context_match = re.search(r'(.*?)(?##\s+Question:?)', content, re.DOTALL)
        if context_match:
            question_data['context'] = context_match.group(1).strip()
        
        return question_data
    
    def generate_answer_stub(self, question_data: Dict[str, Any]) -> str:
        """Generate answer file structure"""
        question_num = question_data['question_number']
        title = question_data.get('title', f'Question {question_num}')
        query = question_data.get('query', question_data.get('content', ''))
        
        answer_template = f"""# âœ… {title}

## **Query:**

{query}

---

## **FAME's Response:**

*FAME is processing this question and will provide a comprehensive answer...*

---

## **Analysis:**

*[FAME's detailed analysis will appear here]*

---

## **Key Insight:**

*[FAME's key insight will appear here]*

---

## **Assessment:**

*[FAME's self-assessment will appear here]*

---

*Generated by FAME on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        return answer_template
    
    def process_question_command(self, command: str) -> str:
        """Process commands related to questions"""
        command_lower = command.lower().strip()
        
        if 'list questions' in command_lower or 'show questions' in command_lower:
            unanswered = self.find_unanswered_questions()
            if unanswered:
                response = f"Found {len(unanswered)} unanswered question(s):\n\n"
                for q in unanswered:
                    response += f"  Question {q['question_number']}: {q['question_file'].name}\n"
                return response
            else:
                return "No unanswered questions found."
        
        if 'answer question' in command_lower or 'process question' in command_lower:
            # Extract question number
            match = re.search(r'(\d+)', command_lower)
            if match:
                question_num = match.group(1)
                return self.handle_question(question_num)
            else:
                # Answer next unanswered question
                unanswered = self.find_unanswered_questions()
                if unanswered:
                    return self.handle_question(unanswered[0]['question_number'])
                else:
                    return "No unanswered questions to process."
        
        if 'answer all' in command_lower:
            unanswered = self.find_unanswered_questions()
            if not unanswered:
                return "No unanswered questions found."
            
            results = []
            for q in unanswered:
                result = self.handle_question(q['question_number'])
                results.append(f"Question {q['question_number']}: {result}")
            
            return "\n\n".join(results)
        
        return None
    
    def handle_question(self, question_number: str) -> str:
        """Handle a specific question number"""
        question_file = self.workspace_path / f'QUESTION_{question_number}.md'
        answer_file = self.workspace_path / f'QUESTION_{question_number}_ANSWER.md'
        
        if not question_file.exists():
            return f"Question file QUESTION_{question_number}.md not found."
        
        # Read question
        question_data = self.read_question_file(question_file)
        
        # Generate answer stub
        answer_content = self.generate_answer_stub(question_data)
        
        # Save answer file
        answer_file.write_text(answer_content, encoding='utf-8')
        
        return f"Question {question_number} processed. Answer stub created at {answer_file.name}. FAME will now analyze and complete the answer."


def main():
    """Test the question handler"""
    handler = FAMEQuestionHandler()
    
    print("FAME Question Handler")
    print("=" * 60)
    
    unanswered = handler.find_unanswered_questions()
    print(f"\nFound {len(unanswered)} unanswered question(s):\n")
    
    for q in unanswered:
        print(f"  Question {q['question_number']}: {q['question_file'].name}")
        question_data = handler.read_question_file(q['question_file'])
        print(f"    Title: {question_data.get('title', 'N/A')}")
        if question_data.get('query'):
            query_preview = question_data['query'][:100] + "..." if len(question_data['query']) > 100 else question_data['query']
            print(f"    Query: {query_preview}")
        print()

if __name__ == "__main__":
    main()

