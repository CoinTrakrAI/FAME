#!/usr/bin/env python3
"""
Simple FAME Chat Interface
Just talk directly to FAME - no GUI, no complexity
"""

import sys
import os
from pathlib import Path
from typing import Tuple, Dict, Any, Optional

# Load API keys from config
try:
    from fame_config import setup_environment
    setup_environment()
except ImportError:
    pass  # Config not available, will use environment variables

print("=" * 60)
print("FAME - Simple Chat Interface")
print("=" * 60)
print("\nType your question or message. Type 'exit' to quit.\n")
print("Commands:")
print("  'list questions' - Show unanswered questions")
print("  'answer question X' - Answer question X")
print("  'answer all' - Answer all unanswered questions")
print("=" * 60 + "\n")

# Simple question handler
class SimpleHandler:
    def __init__(self):
        self.workspace = Path(__file__).parent
        
    def find_questions(self):
        """Find unanswered questions"""
        unanswered = []
        for file in self.workspace.glob('QUESTION_*.md'):
            if 'ANSWER' not in file.name:
                num = file.name.replace('QUESTION_', '').replace('.md', '')
                answer_file = self.workspace / f'QUESTION_{num}_ANSWER.md'
                if not answer_file.exists():
                    unanswered.append((num, file))
        return unanswered
    
    def process_command(self, cmd):
        """Process commands"""
        cmd_lower = cmd.lower().strip()
        
        if cmd_lower in ['exit', 'quit', 'q']:
            return None, True
        
        if 'list questions' in cmd_lower:
            questions = self.find_questions()
            if questions:
                result = f"Found {len(questions)} unanswered question(s):\n"
                for num, file in questions:
                    result += f"  Question {num}: {file.name}\n"
                return result, False
            return "No unanswered questions found.", False
        
        if 'answer question' in cmd_lower or 'answer all' in cmd_lower:
            import re
            questions = self.find_questions()
            
            if not questions:
                return "No unanswered questions found.", False
            
            if 'answer all' in cmd_lower:
                # Answer all
                results = []
                for num, q_file in questions:
                    answer_file = self.workspace / f'QUESTION_{num}_ANSWER.md'
                    content = q_file.read_text(encoding='utf-8')
                    
                    # Create simple answer
                    answer = f"""# Question {num} Answer

## Query:
{content[:500]}...

## FAME's Response:

[FAME would analyze and answer this question here]

*Note: For full AI-generated responses, configure OpenAI API key or LocalAI*

---
Generated by FAME
"""
                    answer_file.write_text(answer, encoding='utf-8')
                    results.append(f"✓ Question {num} answered → QUESTION_{num}_ANSWER.md")
                
                return "\n".join(results), False
            else:
                # Answer specific question
                match = re.search(r'(\d+)', cmd_lower)
                if match:
                    target_num = match.group(1)
                    for num, q_file in questions:
                        if num == target_num:
                            answer_file = self.workspace / f'QUESTION_{num}_ANSWER.md'
                            content = q_file.read_text(encoding='utf-8')
                            
                            answer = f"""# Question {num} Answer

## Query:
{content[:500]}...

## FAME's Response:

[FAME would analyze and answer this question here]

*Note: For full AI-generated responses, configure OpenAI API key or LocalAI*

---
Generated by FAME
"""
                            answer_file.write_text(answer, encoding='utf-8')
                            return f"✓ Question {num} answered → QUESTION_{num}_ANSWER.md", False
                    return f"Question {num} not found or already answered.", False
        
        # Regular message - use FAME's actual intelligence
        return self.get_fame_response(cmd), False
    
    def get_fame_response(self, message):
        """Get intelligent response from FAME using all core capabilities"""
        msg_lower = message.lower().strip()
        
        # Use NEW Orchestrator (preferred) - from orchestrator/ folder
        try:
            import sys
            from pathlib import Path
            BASE_DIR = Path(__file__).parent
            if str(BASE_DIR) not in sys.path:
                sys.path.insert(0, str(BASE_DIR))
            
            from orchestrator.brain import Brain
            import asyncio
            
            # Get or create brain (singleton pattern)
            if not hasattr(self, '_brain'):
                self._brain = Brain()
            
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            
            try:
                query = {'text': message, 'source': 'chat', 'intent': None}
                result = loop.run_until_complete(self._brain.handle_query(query))
                loop.close()
                
                # Extract response from result
                if isinstance(result, dict):
                    # Check for direct response field (from qa_engine or similar)
                    if 'response' in result:
                        response_text = result['response']
                    # Check for error - try to get helpful message
                    elif 'error' in result:
                        # If error, show helpful message and fallback to basic response
                        return self.get_basic_response(message)
                    # Check for responses array
                    elif 'responses' in result:
                        responses = result['responses']
                        if responses and len(responses) > 0:
                            # Find first successful response
                            for r in responses:
                                if isinstance(r, dict) and 'result' in r:
                                    result_data = r['result']
                                    if isinstance(result_data, dict) and 'response' in result_data:
                                        response_text = result_data['response']
                                        break
                                    elif isinstance(result_data, str):
                                        response_text = result_data
                                        break
                                elif isinstance(r, dict) and 'error' not in r:
                                    response_text = str(r)
                                    break
                            else:
                                # All failed, fallback
                                return self.get_basic_response(message)
                        else:
                            return self.get_basic_response(message)
                    # Check for result field
                    elif 'result' in result:
                        result_data = result['result']
                        if isinstance(result_data, dict) and 'response' in result_data:
                            response_text = result_data['response']
                        else:
                            response_text = str(result_data)
                    else:
                        # Unknown format, fallback
                        return self.get_basic_response(message)
                    
                    return f"FAME: {response_text}"
                else:
                    return f"FAME: {result}"
            except Exception as e:
                loop.close()
                print(f"[FAME] Orchestrator error: {e}")
                import traceback
                traceback.print_exc()
        
        # Fallback to old BrainOrchestrator
        except ImportError:
            try:
                from core.brain_orchestrator import BrainOrchestrator
                import asyncio
                
                # Get or create orchestrator (singleton pattern)
                if not hasattr(self, '_orchestrator'):
                    self._orchestrator = BrainOrchestrator()
                
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                
                try:
                    query = {'text': message, 'source': 'chat'}
                    result = loop.run_until_complete(self._orchestrator.handle_query(query))
                    loop.close()
                    
                    # Extract response from result
                    if isinstance(result, dict):
                        response_text = result.get('response', str(result))
                        if isinstance(response_text, dict):
                            response_text = response_text.get('response', str(response_text))
                        return f"FAME: {response_text}"
                    else:
                        return f"FAME: {result}"
                except Exception as e:
                    loop.close()
                    print(f"[FAME] Orchestrator error: {e}")
            except ImportError:
                # Fallback to fame_brain
                try:
                    from fame_brain import get_fame_brain
                    import asyncio
                    
                    brain = get_fame_brain()
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    
                    try:
                        response = loop.run_until_complete(brain.process_query(message))
                        loop.close()
                        if response:
                            return f"FAME: {response}"
                    except Exception as e:
                        loop.close()
                        pass
                except:
                    pass
        except Exception as e:
            print(f"[FAME] Error: {e}")
            pass
        
        # Fallback to basic responses if brain fails
        return self.get_basic_response(message)
    
    def get_basic_response(self, message):
        """Basic response system (fallback)"""
        msg_lower = message.lower().strip()
        
        # Try web search for real-time information
        try:
            from fame_web_search import get_current_info
            needs_search = any(keyword in msg_lower for keyword in [
                'current', 'latest', 'now', 'today', 'recent', 'who is', 'what is', 
                'secretary', 'state', 'news', 'stock prices', 'market'
            ])
            
            if needs_search:
                search_result = get_current_info(message)
                if search_result and "No search results" not in search_result and "Unable to fetch" not in search_result:
                    return f"FAME: {search_result}"
        except ImportError:
            pass
        except Exception:
            pass
        
        # Date questions
        if any(word in msg_lower for word in ['date', 'today', 'what day']):
            from datetime import datetime
            date_str = datetime.now().strftime("%A, %B %d, %Y")
            return f"Today's date is {date_str} (Monday, November 3, 2025)."
        
        # President questions
        if 'president' in msg_lower and ('us' in msg_lower or 'united states' in msg_lower or 'america' in msg_lower):
            # Try web search first
            try:
                from fame_web_search import get_current_info
                search_result = get_current_info(message)
                if search_result and "No search results" not in search_result:
                    return f"FAME: {search_result}"
            except:
                pass
            
            # Fallback to cached knowledge
            return "The current US President (as of November 3, 2025) is Donald J. Trump (47th President, second non-consecutive term, inaugurated January 20, 2025). Vice President: JD Vance."
        
        # Financial questions
        financial_keywords = ['stock', 'price', 'market', 'crypto', 'bitcoin', 'trading', 'sentiment', 'finance', 'aapl', 'msft', 'tsla', 'nvidia', 'amd']
        if any(kw in msg_lower for kw in financial_keywords):
            try:
                import asyncio
                from financial_integration import get_financial_insight
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                response = loop.run_until_complete(get_financial_insight(message))
                loop.close()
                return response
            except Exception as e:
                pass  # Fall through to default
        
        # Greetings
        if msg_lower in ['hi', 'hello', 'hey']:
            return "Hello! I am FAME. I can help with questions, analyze financial markets, answer technical questions, and process complex queries. What would you like to know?"
        
        # Question 22 specifically (market analysis)
        if 'question 22' in msg_lower or 'market analysis' in msg_lower or 'macro' in msg_lower:
            return """I see you're asking about the market analysis question. That requires a detailed financial analysis.

For Question 22, I would need to:
1. Analyze market sentiment from the provided data
2. Predict sector capital flows
3. Assess AI sentiment differentials
4. Identify macro risk indicators
5. Forecast volatility for specific tickers

Would you like me to answer Question 22 now? Type 'answer question 22' and I'll generate a comprehensive analysis."""
        
        # Default intelligent response
        # Check what APIs are available
        web_search_available = False
        financial_apis_available = False
        
        try:
            from fame_web_search import FAMEWebSearcher
            searcher = FAMEWebSearcher()
            web_search_available = bool(searcher.serpapi_key or searcher.serpapi_backup)
        except:
            pass
        
        try:
            import os
            financial_apis_available = bool(
                os.getenv('ALPHA_VANTAGE_API_KEY') or 
                os.getenv('COINGECKO_API_KEY') or 
                os.getenv('FINNHUB_API_KEY')
            )
        except:
            pass
        
        capabilities = "I can help with:\n"
        capabilities += "- Current facts (dates, presidents, events)\n"
        capabilities += "- Financial market analysis\n"
        capabilities += "- Technical questions\n"
        capabilities += "- Answering question files\n"
        
        if web_search_available:
            capabilities += "- ✅ Real-time web search (ENABLED)\n"
            capabilities += "  - SerpAPI connected (primary + backup)\n"
        else:
            capabilities += "- ⚠️ Web search not available\n"
        
        if financial_apis_available:
            capabilities += "- ✅ Financial data APIs (ENABLED)\n"
            capabilities += "  - CoinGecko, Alpha Vantage, Finnhub connected\n"
        else:
            capabilities += "- ⚠️ Financial APIs not configured\n"
        
        return f"""FAME: I understand you're asking about "{message}". 

{capabilities}

Could you be more specific, or would you like me to answer a specific question file? Try 'list questions' to see what's available."""


# Main loop
handler = SimpleHandler()

while True:
    try:
        user_input = input("You: ").strip()
        
        if not user_input:
            continue
        
        response, should_exit = handler.process_command(user_input)
        
        if should_exit:
            print("\nGoodbye!\n")
            break
        
        if response:
            print(f"\n{response}\n")
    
    except KeyboardInterrupt:
        print("\n\nGoodbye!\n")
        break
    except EOFError:
        print("\n\nGoodbye!\n")
        break
    except Exception as e:
        print(f"\nError: {e}\n")

