Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Australia • Brazil • Mexico • Singapore • United Kingdom • United StatesFUNDAMENTALS O F PYTHON: 
FIRST PROGRAMS
KENNETH A. L AMBERT
MARTIN OSB ORNE,  
CONTRIBUTING AUTH ORSECOND EDITION
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

This is an electronic version of the print textbook. Due to electronic rights restrictions,
some third party content may be suppressed. Editorial review has deemed that any suppressed 
content does not materially affect the overall learning experience. The publisher reserves the right 
to remove content from this title at any time if subsequent rights restrictions require it. For
valuable information on pricing, previous editions, changes to current editions, and alternate 
formats, please visit www.cengage.com/highered to search by ISBN#, author, title, or keyword for 
materials in your areas of interest.
Important Notice: Media content referenced within the product description or the product 
text may not be available in the eBook version.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Fundamentals of Python:  
First Programs, Second Edition
 Kenneth A. Lambert
SVP, GM Skills: Jonathan Lau 
Product Team Manager: Kristin 
McNary 
Associate Product Manager: Kate 
Mason 
Executive Director of Development: 
Marah Bellegarde 
Senior Content Development 
 Manager: Leigh Hefferon 
Content Development Manager: Jill 
Gallagher 
Senior Content Developer: Natalie 
Pashoukos 
Product Assistant: Jake Toth 
Marketing Director: Michele McTighe 
Marketing Manager: Stephanie 
Albracht 
Senior Content Project Manager: 
Jennifer Feltri-George 
Senior Designer/Art Director: Diana 
Graham 
Cover image: Digital_Art/  
Shutterstock.com
Production Service/Composition:  
SPi Glob al Cengage is a leading provider of customized learning solutions with  
employees residing in nearly 40 different countries and sales in more  
than 125 countries around the world. Find your local representative  
at www.cengage.com .
Cengage products are represented in Canada by Nelson Education, Ltd.
To learn more about Cengage, visit www.cengage.com .
Purchase any of our products at your local college store or at our  
 preferred online store www.cengagebrain.com .
© 2019, 2012 Cengage
ALL RIGHTS RESERVED. No part of this work covered by the copy-
right herein may be reproduced or distributed in any form or by 
any means, except as permitted by U.S. copyright law, without the 
prior written permission of the copyright owner.
Unless otherwise noted all tables/figures exhibits are © 2019  Cengage®
Cengage
20 Channel Center Street
Boston, MA, 02210Library of Congress Control Number: 2017952738
Softbound ISBN: 978-1-337-56009-2
Loose Leaf ISBN: 978-1-337-69934-1
USA
Printed in the United States of America
Print Number: 01                 Print Y ear: 2017Notice to the Reader
Publisher does not warrant or guarantee any of the products described herein or perform any independent analysis   
in connection with any of the product information contained herein. Publisher does not assume, and expressly  
disclaims, any obligation to obtain and include information other than that provided to it by the manufacturer. The  
reader is expressly warned to consider and adopt all safety precautions that might be indicated by the activities  
described herein and to avoid all potential hazards. By following the instructions contained herein, the reader willingly  
assumes all risks in connection with such instructions. The publisher makes no representations or warranties of any  
kind, including but not limited to, the warranties of fitness for particular purpose or merchantability, nor are any  
such representations implied with respect to the material set forth herein, and the publisher takes no responsibility  
with respect to such material. The publisher shall not be liable for any special, consequential, or exemplary damages  
resulting, in whole or part, from the readers’ use of, or reliance upon, this material.For product information and technology assistance, contact us  
at Cengage Customer & Sales Support, 1-800-354-9706
For permission to use material from this text or product, submit  
all requests online at www.cengage.com/permissions .
Further permissions questions can be e-mailed to  
permissionrequest@cengage.com
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

 Preface  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  xiii
CHAPTER 1 I ntroduction    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   1
Two Fundamental Ideas of Computer Science:   
Algorithms and Information Processing .  .  .  .  .  .  .  .  .  .  . 2
Algorithms  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 2
Information Processing    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 4
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 5
The Structure of a Modern Computer System    .   .   .   .   .   .   .   . 6
Computer Hardware  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 6
Computer Software  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 7
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 9
A Not-So-Brief History of Computing Systems    .   .   .   .   .   .   .   . 9
Before Electronic Digital Computers .  .  .  .  .  .  .  .  .  .  .  11
The First Electronic Digital Computers (1940–1950)  .  .  .  13
The First Programming Languages (1950–1965) .  .  .  .  .  14
Integrated Circuits, Interaction,  
and Timesharing (1965–1975)    .  .  .  .  .  .  .  .  .  .  .  .  16
Personal Computing and Networks (1975–1990) .  .  .  .  .  17
Consultation, Communication,  
and E-Commerce (1990–2000)    .   .   .   .   .   .   .   .   .   .   .   .   19
Mobile Applications and Ubiquitous  
Computing (2000–present)  .  .  .  .  .  .  .  .  .  .  .  .  .  .  21
Getting Started with Python Programming  .  .  .  .  .  .  .  .  .  22
Running Code in the Interactive Shell .  .  .  .  .  .  .  .  .  .  22
Input, Processing, and Output    .   .   .   .   .   .   .   .   .   .   .   .   .   24
Editing, Saving, and Running a Script  .  .  .  .  .  .  .  .  .  .  27
Behind the Scenes: How Python Works    .   .   .   .   .   .   .   .   .   28
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  29
Detecting and Correcting Syntax Errors  .  .  .  .  .  .  .  .  .  .  29
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  30
Suggestions for Further Reading  .  .  .  .  .  .  .  .  .  .  .  .  .  30
Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  31Table of Contents
iii
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Review Questions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  32
Projects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   33
CHAPTER 2 S oftware  Development, Data Types,  
and Expressions    .   .   .   .   .   .   .   .   .   .   .   .   . 34
The Software Development Process .  .  .  .  .  .  .  .  .  .  .  .  35
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  37
Case Study: Income Tax Calculator  .  .  .  .  .  .  .  .  .  .  .  .  38
Strings, Assignment, and Comments    .   .   .   .   .   .   .   .   .   .   .   41
Data Types  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  41
String Literals .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  42
Escape Sequences    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   43
String Concatenation    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  43
Variables and the Assignment Statement    .  .  .  .  .  .  .  .  44
Program Comments and Docstrings .  .  .  .  .  .  .  .  .  .  .  45
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  46
Numeric Data Types and Character Sets.  .  .  .  .  .  .  .  .  .  47
Integers    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   47
Floating-Point Numbers    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  47
Character Sets .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  48
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  49
Expressions    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  49
Arithmetic Expressions .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  50
Mixed-Mode Arithmetic and Type Conversions    .   .   .   .   .   .   52
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  53
Using Functions and Modules .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  54
Calling Functions: Arguments and Return Values  .  .  .  .  .  54
The math Module  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  55
The Main Module    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   56
Program Format and Structure  .  .  .  .  .  .  .  .  .  .  .  .  .  57
Running a Script from a Terminal Command Prompt    .  .  .  57
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  59
Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  59
Review Questions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  61
Projects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   62
CHAPTER 3 Loops and Selection Statements    .  .  .  .  .  . 64
Definite Iteration: The for Loop    .  .  .  .  .  .  .  .  .  .  .  .  .  65
Executing a Statement a Given Number of Times .  .  .  .  .  65
Count-Controlled Loops    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   66
Augmented Assignment    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   67iv
C O N T E N T S 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Loop Errors: Off-by-One Error.  .  .  .  .  .  .  .  .  .  .  .  .  .  68
Traversing the Contents of a Data Sequence .  .  .  .  .  .  .  68
Specifying the Steps in the Range    .  .  .  .  .  .  .  .  .  .  .  69
Loops That Count Down  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  69
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  70
Formatting Text for Output  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  70
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  72
Case Study: An Investment Report    .   .   .   .   .   .   .   .   .   .   .   .   73
Selection: if and if-else Statements  .  .  .  .  .  .  .  .  .  .  77
The Boolean Type, Comparisons, and Boolean  
Expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  77
if-else Statements    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  78
One-Way Selection Statements  .  .  .  .  .  .  .  .  .  .  .  .  .  79
Multi-Way if Statements .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  80
Logical Operators and Compound Boolean Expressions .  .  82
Short-Circuit Evaluation    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   84
Testing Selection Statements .  .  .  .  .  .  .  .  .  .  .  .  .  .  84
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  85
Conditional Iteration: The while Loop .  .  .  .  .  .  .  .  .  .  .  86
The Structure and Behavior of a while Loop .  .  .  .  .  .  .  86
Count Control with a while Loop  .  .  .  .  .  .  .  .  .  .  .  .  87
The while True Loop and the break Statement  .  .  .  .  .  88
Random Numbers  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  90
Loop Logic, Errors, and Testing    .  .  .  .  .  .  .  .  .  .  .  .  91
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  92
Case Study: Approximating Square Roots  .  .  .  .  .  .  .  .  .  92
Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  96
Review Questions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  97
Projects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   99
CHAPTER 4 S trings and Text Files  .  .  .  .  .  .  .  .  .  . 102
Accessing Characters and Substrings in Strings  .  .  .  .  .   103
The Structure of Strings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   103
The Subscript Operator    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    104
Slicing for Substrings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   105
Testing for a Substring with the in Operator .  .  .  .  .  .   105
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   106
Data Encryption .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   106
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   109
Strings and Number Systems .  .  .  .  .  .  .  .  .  .  .  .  .  .   109
The Positional System for Representing Numbers    .  .  .   110
Converting Binary to Decimal .  .  .  .  .  .  .  .  .  .  .  .  .   111v
C O N T E N T S 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Converting Decimal to Binary .  .  .  .  .  .  .  .  .  .  .  .  .   112
Conversion Shortcuts  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   112
Octal and Hexadecimal Numbers  .  .  .  .  .  .  .  .  .  .  .   113
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   114
String Methods  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   115
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   118
Text Files .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   118
Text Files and Their Format .  .  .  .  .  .  .  .  .  .  .  .  .  .   118
Writing Text to a File .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   119
Writing Numbers to a File    .   .   .   .   .   .   .   .   .   .   .   .   .   .    119
Reading Text from a File  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   120
Reading Numbers from a File .  .  .  .  .  .  .  .  .  .  .  .  .   121
Accessing and Manipulating Files and Directories  
on Disk  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   122
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   125
Case Study: Text Analysis    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    126
Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   130
Review Questions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   131
Projects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    132
CHAPTER 5 Lists and Dictionaries  .  .  .  .  .  .  .  .  .  . 134
Lists .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   135
List Literals and Basic Operators  .  .  .  .  .  .  .  .  .  .  .   135
Replacing an Element in a List  .  .  .  .  .  .  .  .  .  .  .  .   138
List Methods for Inserting and Removing Elements  .  .  .   138
Searching a List .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   140
Sorting a List .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   140
Mutator Methods and the Value None .  .  .  .  .  .  .  .  .   141
Aliasing and Side Effects .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   141
Equality: Object Identity and Structural  
Equivalence  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   143
Example: Using a List to Find the Median  
of a Set of Numbers  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   143
Tuples  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   144
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   145
Defining Simple Functions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   146
The Syntax of Simple Function Definitions  .  .  .  .  .  .  .   146
Parameters and Arguments .  .  .  .  .  .  .  .  .  .  .  .  .  .   147
The return Statement .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   147
Boolean Functions .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   148
Defining a main Function .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   148
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   149
Case Study: Generating Sentences  .  .  .  .  .  .  .  .  .  .  .   150vi
C O N T E N T S 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Dictionaries .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   153
Dictionary Literals .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   153
Adding Keys and Replacing Values    .   .   .   .   .   .   .   .   .   .    154
Accessing Values  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   154
Removing Keys  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   155
Traversing a Dictionary    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   155
Example: The Hexadecimal System Revisited .  .  .  .  .  .   156
Example: Finding the Mode of a List of Values  .  .  .  .  .   157
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   158
Case Study: Nondirective Psychotherapy    .   .   .   .   .   .   .   .    159
Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   163
Review Questions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   164
Projects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    165
CHAPTER 6 Design with Functions  .  .  .  .  .  .  .  .  .  . 167
A Quick Review of What Functions Are and  How  
They Work .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   168
Functions as Abstraction Mechanisms .  .  .  .  .  .  .  .  .   169
Functions Eliminate Redundancy    .   .   .   .   .   .   .   .   .   .   .    169
Functions Hide Complexity  .  .  .  .  .  .  .  .  .  .  .  .  .  .   170
Functions Support General Methods with Systematic 
Variations  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   170
Functions Support the Division of Labor .  .  .  .  .  .  .  .   171
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   171
Problem Solving with Top-Down Design    .   .   .   .   .   .   .   .   .    172
The Design of the Text-Analysis Program    .  .  .  .  .  .  .   172
The Design of the Sentence- Generator Program    .   .   .   .    173
The Design of the Doctor Program    .   .   .   .   .   .   .   .   .   .    174
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   176
Design with Recursive Functions    .   .   .   .   .   .   .   .   .   .   .   .    176
Defining a Recursive Function    .  .  .  .  .  .  .  .  .  .  .  .   176
Tracing a Recursive Function .  .  .  .  .  .  .  .  .  .  .  .  .   177
Using Recursive Definitions to Construct Recursive  
Functions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   178
Recursion in Sentence Structure    .   .   .   .   .   .   .   .   .   .   .    179
Infinite Recursion  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   179
The Costs and Benefits of Recursion    .   .   .   .   .   .   .   .   .    180
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   182
Case Study: Gathering Information from a File System    .   .    183
Managing a Program’s Namespace  .  .  .  .  .  .  .  .  .  .  .   190
Module Variables, Parameters, and Temporary  
Variables    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    190
Scope  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   191vii
C O N T E N T S 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Lifetime    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    192
Using Keywords for Default and Optional Arguments    .   .    193
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   194
Higher-Order Functions    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   195
Functions as First-Class Data Objects  .  .  .  .  .  .  .  .  .   195
Mapping    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    196
Filtering    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    197
Reducing .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   197
Using lambda to Create Anonymous Functions .  .  .  .  .   198
Creating Jump Tables    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    199
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   199
Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   200
Review Questions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   202
Projects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    203
CHAPTER 7 S imple Graphics and Image Processing .  .  . 205
Simple Graphics .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   206
Overview of Turtle Graphics    .   .   .   .   .   .   .   .   .   .   .   .   .    206
Turtle Operations  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   207
Setting Up a turtle.cfg File and Running IDLE.  .  .  .  .  .   209
Object Instantiation and the turtle Module  .  .  .  .  .  .   210
Drawing Two-Dimensional Shapes .  .  .  .  .  .  .  .  .  .  .   212
Examining an Object’s Attributes  .  .  .  .  .  .  .  .  .  .  .   213
Manipulating a Turtle’s Screen    .   .   .   .   .   .   .   .   .   .   .   .    214
Taking a Random Walk .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   214
Colors and the RGB System    .   .   .   .   .   .   .   .   .   .   .   .   .    215
Example: Filling Radial Patterns with Random  
Colors    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   216
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   218
Case Study: Recursive Patterns in Fractals    .  .  .  .  .  .  .   218
Image Processing .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   222
Analog and Digital Information    .   .   .   .   .   .   .   .   .   .   .   .    223
Sampling and Digitizing Images .  .  .  .  .  .  .  .  .  .  .  .   223
Image File Formats    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    224
Image- Manipulation Operations  .  .  .  .  .  .  .  .  .  .  .  .   224
The Properties of Images    .  .  .  .  .  .  .  .  .  .  .  .  .  .   225
The images Module  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   225
A Loop Pattern for Traversing a Grid   .   .   .   .   .   .   .   .   .    228
A Word on Tuples  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   229
Converting an Image to Black and White .  .  .  .  .  .  .  .   230
Converting an Image to Grayscale    .  .  .  .  .  .  .  .  .  .   231
Copying an Image .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   232
Blurring an Image  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   233viii
C O N T E N T S 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Edge Detection  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   234
Reducing the Image Size.  .  .  .  .  .  .  .  .  .  .  .  .  .  .   235
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   237
Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   237
Review Questions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   238
Projects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    240
CHAPTER 8 G raphical User Interfaces    .  .  .  .  .  .  .  . 244
The Behavior of Terminal- Based Programs and   G U I-Based 
Programs  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   245
The Terminal- Based Version    .  .  .  .  .  .  .  .  .  .  .  .  .   246
The GUI-Based Version .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   246
Event-Driven Programming  .  .  .  .  .  .  .  .  .  .  .  .  .  .   248
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   249
Coding Simple GUI-Based Programs .  .  .  .  .  .  .  .  .  .  .   249
A Simple “ Hello World” Program    .  .  .  .  .  .  .  .  .  .  .   249
A Template for All GUI Programs    .   .   .   .   .   .   .   .   .   .   .    251
The Syntax of Class and Method Definitions  .  .  .  .  .  .   251
Subclassing and Inheritance as Abstraction   
Mechanisms .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   252
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   253
Windows and Window Components    .   .   .   .   .   .   .   .   .   .   .    253
Windows and Their Attributes .  .  .  .  .  .  .  .  .  .  .  .  .   253
Window Layout    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    254
Types of Window Components and Their Attributes  .  .  .   256
Displaying Images .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   257
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   259
Command Buttons and Responding to Events    .   .   .   .   .   .    260
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   262
Input and Output with Entry Fields .  .  .  .  .  .  .  .  .  .  .  .   262
Text Fields  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   262
Integer and Float Fields for Numeric Data  .  .  .  .  .  .  .   264
Using Pop- Up Message Boxes    .  .  .  .  .  .  .  .  .  .  .  .   265
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   267
Defining and Using Instance Variables .  .  .  .  .  .  .  .  .  .   267
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   269
Case Study: The Guessing Game Revisited .  .  .  .  .  .  .  .   269
Other Useful GUI Resources    .   .   .   .   .   .   .   .   .   .   .   .   .   .    273
Using Nested Frames to Organize Components .  .  .  .  .   273
Multi-Line Text Areas .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   275
File Dialogs .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   277
Obtaining Input with Prompter Boxes    .   .   .   .   .   .   .   .   .    280
Check Buttons    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   281ix
C O N T E N T S 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Radio Buttons .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   282
Keyboard Events    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    284
Working with Colors  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   285
Using a Color Chooser .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   287
Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   289
Review Questions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   289
Projects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    290
CHAPTER 9 Design with Classes  .  .  .  .  .  .  .  .  .  .  . 293
Getting Inside Objects and Classes  .  .  .  .  .  .  .  .  .  .  .   294
A First Example: The Student Class    .   .   .   .   .   .   .   .   .    295
Docstrings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   297
Method Definitions .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   297
The __ init__ Method and Instance Variables    .  .  .  .  .   298
The __ str__ Method .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   299
Accessors and Mutators  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   299
The Lifetime of Objects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    299
Rules of Thumb for Defining a Simple Class  .  .  .  .  .  .   300
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   301
Case Study: Playing the Game of Craps  .  .  .  .  .  .  .  .  .   301
Data- Modeling Examples  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   309
Rational Numbers  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   309
Rational Number Arithmetic and Operator Overloading    .    311
Comparison Methods    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    312
Equality and the __ eq__ Method    .  .  .  .  .  .  .  .  .  .  .   313
Savings Accounts and Class Variables .  .  .  .  .  .  .  .  .   314
Putting the Accounts into a Bank .  .  .  .  .  .  .  .  .  .  .   317
Using pickle for Permanent Storage of Objects    .  .  .   319
Input of Objects and the try-except  Statement    .   .   .    320
Playing Cards .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   321
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   324
Case Study: An A TM.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   324
Building a New Data Structure: The Two-Dimensional Grid.   330
The Interface of the Grid Class    .  .  .  .  .  .  .  .  .  .  .   330
The Implementation of the Grid Class: Instance  
Variables for the Data    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   332
The Implementation of the Grid Class: Subscript  
and Search    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    333
Case Study: Data Encryption with a Block Cipher .  .  .  .  .   333
Structuring Classes with Inheritance and Polymorphism .  .   337
Inheritance Hierarchies and Modeling  .  .  .  .  .  .  .  .  .   338
Example 1: A Restricted Savings Account  .  .  .  .  .  .  .   339
Example 2: The Dealer and a Player in the Game  
of Blackjack  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   340x
C O N T E N T S 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Polymorphic Methods   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   344
The Costs and Benefits of Object-Oriented   
Programming    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    345
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   346
Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   347
Review Questions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   348
Projects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    349
CHAPTER 10 M ultithreading,  Networks, and Client/ Server 
Programming .  .  .  .  .  .  .  .  .  .  .  .  .  . 352
Threads and Processes    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    353
Threads    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    354
Sleeping Threads  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   357
Producer, Consumer, and Synchronization .  .  .  .  .  .  .   358
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   364
The Readers and Writers Problem .  .  .  .  .  .  .  .  .  .  .  .   364
Using the SharedCell  Class .  .  .  .  .  .  .  .  .  .  .  .  .   365
Implementing the Interface of the SharedCell  Class .  .   366
Implementing the Helper Methods of the  
SharedCell  Class .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   368
Testing the SharedCell  Class with a Counter Object .  .   369
Defining a Thread- Safe Class .  .  .  .  .  .  .  .  .  .  .  .  .   370
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   371
Networks, Clients, and Servers .  .  .  .  .  .  .  .  .  .  .  .  .   371
IP Addresses  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   372
Ports, Servers, and Clients .  .  .  .  .  .  .  .  .  .  .  .  .  .   373
Sockets and a Day/ Time Client Script .  .  .  .  .  .  .  .  .   373
A Day/ Time Server Script   .   .   .   .   .   .   .   .   .   .   .   .   .   .    375
A Two-Way Chat Script .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   377
Handling Multiple Clients Concurrently .  .  .  .  .  .  .  .  .   378
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   380
Case Study: Setting Up Conversations between Doctors  
and Patients .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   381
Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   386
Review Questions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   387
Projects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    388
CHAPTER 11 S earching,  Sorting, and Complexity Analysis   390
Measuring the Efficiency of Algorithms    .   .   .   .   .   .   .   .   .    391
Measuring the Run Time of an Algorithm .  .  .  .  .  .  .  .   391
Counting Instructions    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    394
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   396xi
C O N T E N T S 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Complexity Analysis  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   397
Orders of Complexity    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    397
Big-O Notation    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   399
The Role of the Constant of Proportionality    .   .   .   .   .   .    400
Measuring the Memory Used by an Algorithm    .  .  .  .  .   400
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   401
Search Algorithms .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   401
Search for a Minimum  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   401
Sequential Search of a List .  .  .  .  .  .  .  .  .  .  .  .  .  .   402
Best-Case, Worst-Case, and Average-Case   
Performance .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   403
Binary Search of a List .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   403
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   405
Basic Sort Algorithms  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   405
Selection Sort   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   406
Bubble Sort.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   407
Insertion Sort.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   408
Best-Case, Worst-Case, and Average-Case  
Performance Revisited  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   410
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   410
Faster Sorting    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   411
Quicksort .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   411
Merge Sort .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   415
Exercises .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   418
An Exponential Algorithm: Recursive Fibonacci .  .  .  .  .  .   419
Converting Fibonacci to a Linear Algorithm    .  .  .  .  .  .  .   420
Case Study: An Algorithm Profiler .  .  .  .  .  .  .  .  .  .  .  .   421
Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   427
Review Questions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   428
Projects    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .    429
APPENDI X A Python Resources .  .  .  .  .  .  .  .  .  .  .  . 432
APPENDI X B I nstalling the images  
and breezypythongui  Libraries  .  .  .  .  . 434
APPENDI X C T he AP I for Image Processing    .  .  .  .  .  . 436
APPENDI X D T ransition from Python to Java and C++  .  . 438
 G lossary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 439
 I ndex    .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  455xii
C O N T E N T S 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

“Everyone should learn how to code. ” That’s my favorite quote from Suzanne Keen, the 
Thomas Broadus Professor of English and Dean of the College at Washington and Lee Uni -
versity, where I have taught computer science for more than 30 years. The quote also states 
the reason why I wrote the first edition of Fundamentals of Python: First Programs , and why 
I now offer you this second edition. The book is intended for an introductory course in pro -
gramming and problem solving. It covers the material taught in a typical Computer Science 1  
course (CS1) at the undergraduate or high school level.
This book covers five major aspects of computing:
1. Programming Basics —Data types, control structures, algorithm development, and 
program design with functions are basic ideas that you need to master in order to 
solve problems with computers. This book examines these core topics in detail and 
gives you practice employing your understanding of them to solve a wide range of 
problems.
2. Object-Oriented Programming (OOP) —Object-oriented programming is the 
dominant programming paradigm used to develop large software systems. This 
book introduces you to the fundamental principles of OOP and enables you to 
apply them successfully.
3. Data and Information Processing —Most useful programs rely on data structures 
to solve problems. These data structures include strings, arrays, files, lists, and dic-
tionaries. This book introduces you to these commonly used data structures and 
includes examples that illustrate criteria for selecting the appropriate data struc-
tures for given problems.
4. Software Development Life Cycle —Rather than isolate software development 
techniques in one or two chapters, this book deals with them throughout in the 
context of numerous case studies. Among other things, you’ll learn that coding a 
program is often not the most difficult or challenging aspect of problem solving  
and software development.
5. Contemporary Applications of Computing —The best way to learn about pro-
gramming and problem solving is to create interesting programs with real-world 
applications. In this book, you’ll begin by creating applications that involve numeri-
cal problems and text processing. For example, you’ll learn the basics of encryption 
techniques such as those that are used to make your credit card number and other 
information secure on the Internet. But unlike many other introductory texts, this Preface
xiii
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

one does not restrict itself to problems involving numbers and text. Most contem-
porary applications involve graphical user interfaces, event-driven programming, 
graphics, image manipulation, and network communications. These topics are not 
consigned to the margins, but are presented in depth after you have mastered the 
basics of programming.
Why Python?
Computer technology and applications have become increasingly more sophisticated over 
the past three decades, and so has the computer science curriculum, especially at the intro-
ductory level. Today’s students learn a bit of programming and problem solving, and they 
are then expected to move quickly into topics like software development, complexity analy-
sis, and data structures that, 30 years ago, were relegated to advanced courses. In addition, 
the ascent of object-oriented programming as the dominant paradigm of problem solving 
has led instructors and textbook authors to implant powerful, industrial-strength program-
ming languages such as C++ and Java in the introductory curriculum. As a result, instead 
of experiencing the rewards and excitement of solving problems with computers, beginning 
computer science students often become overwhelmed by the combined tasks of mastering 
advanced concepts as well as the syntax of a programming language.
This book uses the Python programming language as a way of making the first year of 
studying computer science more manageable and attractive for students and instructors 
alike. Python has the following pedagogical benefits:
 vPython has simple, conventional syntax. Python statements are very close to those of 
pseudocode algorithms, and Python expressions use the conventional notation found in 
algebra. Thus, students can spend less time learning the syntax of a programming lan-
guage and more time learning to solve interesting problems.
 vPython has safe semantics. Any expression or statement whose meaning violates the 
definition of the language produces an error message.
 vPython scales well. It is very easy for beginners to write simple programs in Python. 
Python also includes all of the advanced features of a modern programming language, 
such as support for data structures and object-oriented software development, for use 
when they become necessary.
 vPython is highly interactive. Expressions and statements can be entered at an interpret-
er’s prompts to allow the programmer to try out experimental code and receive immedi-
ate feedback. Longer code segments can then be composed and saved in script files to 
be loaded and run as modules or standalone applications.
 vPython is general purpose. In today’s context, this means that the language includes 
resources for contemporary applications, including media computing and networks.
 vPython is free and is in widespread use in industry. Students can download Python to 
run on a variety of devices. There is a large Python user community, and expertise in 
Python programming has great résumé value.xivPREFACE Why Python?
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

To summarize these benefits, Python is a comfortable and flexible vehicle for expressing 
ideas about computation, both for beginners and for experts. If students learn these ideas 
well in the first course, they should have no problems making a quick transition to other 
languages needed for courses later in the curriculum. Most importantly, beginning students 
will spend less time staring at a computer screen and more time thinking about interesting 
problems to solve.
Organization of the Book
The approach of this text is easygoing, with each new concept introduced only when it is 
needed.
Chapter 1 introduces computer science by focusing on two fundamental ideas, algorithms 
and information processing. A brief overview of computer hardware and software, followed 
by an extended discussion of the history of computing, sets the context for computational 
problem solving.
Chapters 2 and 3 cover the basics of problem solving and algorithm development using the 
standard control structures of expression evaluation, sequencing, Boolean logic, selection, 
and iteration with the basic numeric data types. Emphasis in these chapters is on problem 
solving that is both systematic and experimental, involving algorithm design, testing, and 
documentation.
Chapters 4 and 5 introduce the use of the strings, text files, lists, and dictionaries. These 
data structures are both remarkably easy to manipulate in Python and support some inter-
esting applications. Chapter 5 also introduces simple function definitions as a way of orga-
nizing algorithmic code.
Chapter 6 explores the technique and benefits of procedural abstraction with function 
definitions. Top-down design, stepwise refinement, and recursive design with functions are 
examined as means of structuring code to solve complex problems. Details of namespace 
organization (parameters, temporary variables, and module variables) and communica-
tion among software components are discussed. A section on functional programming 
with higher-order functions shows how to exploit functional design patterns to simplify 
solutions.
Chapter 7 focuses on the use of existing objects and classes to compose programs.  Special 
attention is paid to the application programming interface (API), or set of methods, of  
a class of objects and the manner in which objects cooperate to solve problems. This  
 chapter also introduces two contemporary applications of computing, graphics and  
image  processing—areas in which object-based programming is particularly useful.
Chapter 8 introduces the definition of new classes to construct graphical user interfaces 
(GUIs). The chapter contrasts the event-driven model of GUI programs with the process-
driven model of terminal-based programs. The creation and layout of GUI components 
are explored, as well as the design of GUI-based applications using the model/view pattern. 
The initial approach to defining new classes in this chapter is unusual for an introductory xvPREFACE Organization of the Book
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

textbook: students learn that the easiest way to define a new class is to customize an exist-
ing class using subclassing and inheritance.
Chapter 9 continues the exploration of object-oriented design with the definition of entirely 
new classes. Several examples of simple class definitions from different application domains 
are presented. Some of these are then integrated into more realistic applications, to show 
how object-oriented software components can be used to build complex systems. Emphasis 
is on designing appropriate interfaces for classes that exploit polymorphism.
Chapter 10 covers advanced material related to several important areas of computing: 
concurrent programming, networks, and client/server applications. This chapter thus 
gives students challenging experiences near the end of the first course. Chapter 10 intro-
duces multithreaded programs and the construction of simple network-based client/server 
applications.
Chapter 11 covers some topics addressed at the beginning of a traditional CS2 course. This 
chapter introduces complexity analysis with big-O notation. Enough material is presented 
to enable you to perform simple analyses of the running time and memory usage of algo-
rithms and data structures, using search and sort algorithms as examples.
Special Features
This book explains and develops concepts carefully, using frequent examples and diagrams. 
New concepts are then applied in complete programs to show how they aid in solving prob-
lems. The chapters place an early and consistent emphasis on good writing habits and neat, 
readable documentation.
The book includes several other important features:
 vCase studies—These present complete Python programs ranging from the simple to 
the substantial. To emphasize the importance and usefulness of the software develop-
ment life cycle, case studies are discussed in the framework of a user request, followed 
by analysis, design, implementation, and suggestions for testing, with well-defined tasks 
performed at each stage. Some case studies are extended in end-of-chapter program-
ming projects.
 vChapter objectives and chapter summaries—Each chapter begins with a set of learning 
objectives and ends with a summary of the major concepts covered in the chapter.
 vKey terms and a glossary—When a technical term is introduced in the text, it appears in 
boldface. Definitions of the key terms are also collected in a glossary.
 vExercises—Most major sections of each chapter end with exercise questions that rein-
force the reading by asking basic questions about the material in the section. Each chap-
ter ends with a set of review exercises.
 vProgramming projects—Each chapter ends with a set of programming projects of vary-
ing difficulty.xviPREFACE Special Features
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

 vA software toolkit for image processing—This book comes with an open-source 
Python toolkit for the easy image processing discussed in Chapter 7. The toolkit can be 
obtained from the student downloads page on www.cengage.com,  or at http://home.wlu 
.edu/~lambertk/python/
 vA software toolkit for GUI programming—This book comes with an open-source 
Python toolkit for the easy GUI programming introduced in Chapter 8. The toolkit can 
be obtained from the student downloads page on www.cengage.com,  or at http://home 
.wlu.edu/~lambertk/breezypythongui/
 vAppendices—Four appendices include information on obtaining Python resources, 
installing the toolkits, and using the toolkits’ interfaces.
New in This Edition
The most obvious change in this edition is the addition of full color. All program examples 
include the color coding used in Python’s IDLE, so students can easily identify program 
elements such as keywords, program comments, and function, method, and class names. 
Several new figures have been added to illustrate concepts, and many exercises and pro-
gramming projects have been reworked. The brief history of computing in Chapter 1 has 
been brought up to date. A discussion of a Grid type has been included to give students 
exposure to a two-dimensional data structure. The book remains the only introductory 
Python text with a thorough introduction to realistic GUI programming. The chapter 
on GUIs (Chapter 8) now uses the breezypythongui  toolkit to ease the introduction of 
this topic. The chapter on GUIs has also been placed ahead of the chapter on design with 
classes (Chapter 9). This arrangement allows students to explore the customizing of exist-
ing classes with GUI programming before they tackle the design of entirely new classes in 
the following chapter. Finally, a new section on the readers and writers problem has been 
added to Chapter 10, to illustrate thread-safe access to shared resources.
Instructor Resources
MindTap
MindTap activities for Fundamentals of Python: First Programs  are designed to help stu-
dents master the skills they need in today’s workforce. Research shows employers need 
critical thinkers, troubleshooters, and creative problem-solvers to stay relevant in our 
fast-paced, technology-driven world. MindTap helps you achieve this with assignments 
and activities that provide hands-on practice and real-life relevance. Students are guided 
through assignments that help them master basic knowledge and understanding before 
moving on to more challenging problems. 
All MindTap activities and assignments are tied to defined unit learning objectives. 
 Hands-on coding labs provide real-life application and practice. Readings and dynamic 
visualizations support the lecture, while a post-course assessment measures exactly how xviiPREFACE Instructor Resource s
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

much a student has learned. MindTap provides the analytics and reporting to easily see 
where the class stands in terms of progress, engagement, and completion rates. Use the 
content and learning path as-is or pick-and-choose how our materials will wrap around 
yours. You control what the students see and when they see it. Learn more at http://www 
.cengage.com/mindtap/.
Instructor Companion Site
The following teaching tools are available for download at the Companion Site for this text. 
Simply search for this text at www.cengagebrain.com and choose "Instructor Downloads." 
An instructor login is required.
 vInstructor’s Manual:  The Instructor’s Manual that accompanies this textbook includes 
additional instructional material to assist in class preparation, including items such as 
Overviews, Chapter Objectives, Teaching Tips, Quick Quizzes, Class Discussion Top-
ics, Additional Projects, Additional Resources, and Key Terms. A sample syllabus is also 
available.
 vTest Bank:  Cengage Testing Powered by Cognero is a flexible, online system that allows 
you to:
 vauthor, edit, and manage test bank content from multiple Cengage solutions
 vcreate multiple test versions in an instant
 vdeliver tests from your LMS, your classroom, or wherever you want
 vPowerPoint Presentations:  This text provides PowerPoint slides to accompany each 
chapter. Slides may be used to guide classroom presentations, to make available to stu-
dents for chapter review, or to print as classroom handouts. Files are provided for every 
figure in the text. Instructors may use the files to customize PowerPoint slides, illustrate 
quizzes, or create handouts.
 vSolutions:  Solutions to all programming exercises are available. If an input file is 
needed to run a programming exercise, it is included with the solution file.
 vSource Code:  The source code is available at www.cengagebrain.com.  If an input file is 
needed to run a program, it is included with the source code.
We Appreciate Your Feedback
We have tried to produce a high-quality text, but should you encounter any errors, 
please report them to lambertk@wlu.edu or http://support.cengage.com.  A list of errata, 
should they be found, as well as other information about the book, will be posted on 
the Web site http://home.wlu.edu/~lambertk/python/  and with the student resources at 
www.cengagebrain.com .PREFACE We Appreciate Your Feedback
xviii
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Acknowledgments
I would like to thank my contributing author, Martin Osborne, for many years of advice, 
friendly criticism, and encouragement on several of my book projects. I am also grateful 
to the many students and colleagues at Washington and Lee University who have used this 
book and given helpful feedback on it over the life of the first edition.
In addition, I would like to thank the following reviewers for the time and effort they 
contributed to Fundamentals of Python : Steven Robinett, Great Falls College Montana 
State University; Mark Williams, University of Maryland Eastern Shore; Andrew  Danner, 
 Swarthmore College; Susan Fox, Macalester College; Emily Shepard, Central Carolina 
Community College. 
Also, thank you to the individuals at Cengage who helped to assure that the content of 
all data and solution files used for this text were correct and accurate: John Freitas, MQA 
 Project Leader, and Danielle Shaw, MQA Tester.
Finally, thanks to several other people whose work made this book possible: Kate Mason, 
Associate Product Manager, Cengage; Natalie Pashoukos, Senior Content Developer, 
 Cengage; and Jennifer Feltri-George, Senior Content Project Manager, Cengage. I also 
want to thank Scarlett Lindsay for her superb copyediting of the book and Chandrasekar 
 Subramanian for an excellent job managing the paging of the project. 
Dedication
To my good friends, Lesley and David Novack
Kenneth A. Lambert
Lexington, VAPREFACE Dedicatio n
xix
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

CHAPTER 1
Introduction
After completing this chapter, you will be able to
Describe the basic features of an algorithm
Explain how hardware and software collaborate in  
a  computer’s architecture
Summarize a brief history of computing
Compose and run a simple Python program
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

2   Introduction
CHAPTER 1As a reader of this book, you almost certainly have played a video game and listened to 
digital music. It’s likely that you have watched a digital movie after preparing a snack in a 
microwave oven. Chances are that today you will make a phone call, send or receive a text 
message, take a photo, or consult your favorite social network on a cell phone. You and your 
friends have most likely used a desktop computer or a laptop computer to do some signifi-
cant coursework in high school or college.
These activities rely on something in common: computer technology. Computer technol-
ogy is almost everywhere, not only in our homes but also in our schools and in the places 
where we work and play. Computer technology plays an important role in entertainment, 
education, medicine, manufacturing, communications, government, and commerce. It 
has been said that we have digital lifestyles and that we live in an information age with an 
information-based economy. Some people even claim that nature itself performs computa-
tions on information structures present in DNA and in the relationships among subatomic 
particles.
It’s difficult to imagine our world without computation, although we don’t think about the 
actual computers very much. It’s also hard to imagine that the human race did without 
computer technology for thousands of years, and that computer technology has pervaded 
the world as we know it for only the past 30 years or so.
In the following chapters, you will learn about computer science, which is the study of com-
putation that has made this new technology and this new world possible. You will also learn 
how to use computers effectively and appropriately to enhance your own life and the lives 
of others.
Two Fundamental Ideas of Computer Science: 
 Algorithms and Information Processing
Like most areas of study, computer science focuses on a broad set of interrelated ideas.  
Two of the most basic ones are algorithms  and information processing . In this section, 
these ideas are introduced in an informal way. We will examine them in more detail  
in later chapters.
Algorithms
People computed long before the invention of modern computing devices, and many con-
tinue to use computing devices that we might consider primitive. For example, consider 
how merchants made change for customers in marketplaces before the existence of credit 
cards, pocket calculators, or cash registers. Making change can be a complex activity. It 
probably took you some time to learn how to do it, and it takes some mental effort to get it 
right every time. Let’s consider what’s involved in this process.
According to one method, the first step is to compute the difference between the pur-
chase price and the amount of money that the customer gives the merchant. The result of 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

3Two Fundamental Ideas of Computer Science
this calculation is the total amount that the merchant must return to the purchaser. For 
example, if you buy a dozen eggs at the farmers’ market for $2.39 and you give the farmer a 
$10 bill, she should return $7.61 to you. To produce this amount, the merchant selects the 
appropriate coins and bills that, when added to $2.39, make $10.00.
According to another method, the merchant starts with the purchase price and goes toward 
the amount given. First, coins are selected to bring the price to the next dollar amount (in 
this case, 5 $0.613 dimes, 1 nickel, and 4 pennies), then dollars are selected to bring the 
price to the next 5-dollar amount (in this case, $2), and then, in this case, a $5 bill completes 
the transaction. As you will see in this book, there can be many possible methods or algo-
rithms that solve the same problem, and the choice of the best one is a skill you will acquire 
with practice.
Few people can subtract three-digit numbers without resorting to some manual aids, 
such as pencil and paper. As you learned in grade school, you can carry out subtraction 
with pencil and paper by following a sequence of well-defined steps. You have probably 
done this many times but never made a list of the specific steps involved. Making such 
lists to solve problems is something computer scientists do all the time. For example, the 
following list of steps describes the process of subtracting two numbers using a pencil 
and paper:
Step 1  Write down the two numbers, with the larger number above the smaller num-
ber and their digits aligned in columns from the right.
Step 2  Assume that you will start with the rightmost column of digits and work your 
way left through the various columns.
Step 3  Write down the difference between the two digits in the current column 
of digits, borrowing a 1 from the top number’s next column to the left if 
necessary.
Step 4  If there is no next column to the left, stop. Otherwise, move to the next col-
umn to the left, and go back to Step 3.
If the computing agent  (in this case a human being) follows each of these simple steps cor-
rectly, the entire process results in a correct solution to the given problem. We assume in 
Step 3 that the agent already knows how to compute the difference between the two digits 
in any given column, borrowing if necessary.
To make change, most people can select the combination of coins and bills that represent 
the correct change amount without any manual aids, other than the coins and bills. But the 
mental calculations involved can still be described in a manner similar to the preceding 
steps, and we can resort to writing them down on paper if there is a dispute about the cor-
rectness of the change.
The sequence of steps that describes each of these computational processes is called an 
algorithm . Informally, an algorithm is like a recipe. It provides a set of instructions that 
tells us how to do something, such as make change, bake bread, or put together a piece of 
furniture. More precisely, an algorithm describes a process that ends with a solution to a 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

4   Introduction
CHAPTER 1problem. The algorithm is also one of the fundamental ideas of computer science. An algo-
rithm has the following features:
1. An algorithm consists of a finite number of instructions.
2. Each individual instruction in an algorithm is well defined. This means that the 
action described by the instruction can be performed effectively or be executed  
by a computing agent. For example, any computing agent capable of arithmetic can 
compute the difference between two digits. So an algorithmic step that says “com-
pute the difference between two digits” would be well defined. On the other hand, 
a step that says “divide a number by 0” is not well defined, because no computing 
agent could carry it out.
3. An algorithm describes a process that eventually halts after arriving at a solution to 
a problem. For example, the process of subtraction halts after the computing agent 
writes down the difference between the two digits in the leftmost column of digits.
4. An algorithm solves a general class of problems. For example, an algorithm that 
describes how to make change should work for any two amounts of money whose 
difference is greater than or equal to $0.00.
Creating a list of steps that describe how to make change might not seem like a major 
accomplishment to you. But the ability to break a task down into its component parts is one 
of the main jobs of a computer programmer. Once we write an algorithm to describe a par-
ticular type of computation, we can build a machine to do the computing. Put another way, 
if we can develop an algorithm to solve a problem, we can automate the task of solving the 
problem. You might not feel compelled to write a computer program to automate the task 
of making change, because you can probably already make change yourself fairly easily. But 
suppose you needed to do a more complicated task—such as sorting a list of 100 names. In 
that case, a computer program would be very handy.
Computers can be designed to run a small set of algorithms for performing specialized tasks 
such as operating a microwave oven. But we can also build computers, like the one on your 
desktop, that are capable of performing a task described by any algorithm. These computers 
are truly general-purpose problem-solving machines. They are unlike any machines we have 
ever built before, and they have formed the basis of the completely new world in which we live.
Later in this book, we introduce a notation for expressing algorithms and some suggestions 
for designing algorithms. You will see that algorithms and algorithmic thinking are critical 
underpinnings of any computer system.
Information Processing
Since human beings first learned to write several thousand years ago, they have pro-
cessed information. Information itself has taken many forms in its history, from the marks 
impressed on clay tablets in ancient Mesopotamia; to the first written texts in ancient 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

5Two Fundamental Ideas of Computer Science
Greece; to the printed words in the books, newspapers, and magazines mass-produced 
since the European Renaissance; to the abstract symbols of modern mathematics and sci-
ence used during the past 350 years. Only recently, however, have human beings developed 
the capacity to automate the processing of information by building computers. In the 
modern world of computers, information is also commonly referred to as data. But what is 
information?
Like mathematical calculations, information processing can be described with algorithms. 
In our earlier example of making change, the subtraction steps involved manipulating sym-
bols used to represent numbers and money. In carrying out the instructions of any algo-
rithm, a computing agent manipulates information. The computing agent starts with some 
given information (known as input), transforms this information according to well-defined 
rules, and produces new information, known as output .
It is important to recognize that the algorithms that describe information processing can 
also be represented as information. Computer scientists have been able to represent algo-
rithms in a form that can be executed effectively and efficiently by machines. They have 
also designed real machines, called electronic digital computers, which are capable of exe-
cuting algorithms.
Computer scientists more recently discovered how to represent many other things, such as 
images, music, human speech, and video, as information. Many of the media and commu-
nication devices that we now take for granted would be impossible without this new kind 
of information processing. We examine many of these achievements in more detail in later 
chapters.
Exercises
These short end-of-section exercises are intended to stimulate your thinking about 
computing.
1. List three common types of computing agents.
2. Write an algorithm that describes the second part of the process of making change 
(counting out the coins and bills).
3. Write an algorithm that describes a common task, such as baking a cake or operat-
ing a DVD player.
4. Describe an instruction that is not well defined and thus could not be included as a 
step in an algorithm. Give an example of such an instruction.
5. In what sense is a laptop computer a general-purpose problem-solving machine?
6. List four devices that use computers and describe the information that they process. 
(Hint:  Think of the inputs and outputs of the devices.)
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

6   Introduction
CHAPTER 1The Structure of a Modern Computer System
We now give a brief overview of the structure of modern computer systems. A modern 
computer system consists of hardware  and software . Hardware consists of the physical 
devices required to execute algorithms. Software is the set of these algorithms, represented 
as programs , in particular programming languages . In the discussion that follows, we 
focus on the hardware and software found in a typical desktop computer system, although 
similar components are also found in other computer systems, such as handheld devices 
and ATMs (automatic teller machines).
Computer Hardware
The basic hardware components of a computer are memory , a central processing unit 
(CPU), and a set of input/output devices , as shown in Figure 1-1.
Figure 1-1  Hardware components of a modern computer systemInput deviceOutput deviceCPUMemory
Human users primarily interact with the input and output devices. The input devices 
include a keyboard, a mouse, a trackpad, a microphone, and a touchscreen. Common out-
put devices include a monitor and speakers. Computers can also communicate with the 
external world through various ports that connect them to networks  and to other devices 
such as smartphones and digital cameras. The purpose of most input devices is to convert 
information that human beings deal with, such as text, images, and sounds, into informa-
tion for computational processing. The purpose of most output devices is to convert the 
results of this processing back to human-usable form.
Computer memory is set up to represent and store information in electronic form. Specifi-
cally, information is stored as patterns of binary digits  (1s and 0s). To understand how this 
works, consider a basic device such as a light switch, which can only be in one of two states, 
on or off. Now suppose there is a bank of switches that control 16 small lights in a row. By 
turning the switches off or on, we can represent any pattern of 16 binary digits (1s and 0s) 
as patterns of lights that are on or off. As we will see later in this book, computer scientists 
have discovered how to represent any information, including text, images, and sound, in 
binary form.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

7The Structure of a Modern Computer System
Now, suppose there are 8 of these groups of 16 lights. We can select any group of lights and 
examine or change the state of each light within that collection. We have just developed a 
tiny model of computer memory. The memory has 8 cells, each of which can store 16 bits 
of binary information. A diagram of this model, in which the memory cells are filled with 
binary digits, is shown in Figure 1-2. This memory is also sometimes called primary  or 
internal  or random access memory ( RAM).
Figure 1-2  A model of computer memory1101111011111101101101111110111111111111011110111011101111110111111011111011111100111101110111011110111111111011
1110110111111110Cell 7
Cell 6
Cell 5
Cell 4
Cell 3
Cell 2
Cell 1
Cell 0The information stored in memory can represent any type of data, such as numbers, text, 
images, or sound, or the instructions of a program. We can also store in memory an algorithm 
encoded as binary instructions for the computer. Once the information is stored in memory, we 
typically want to do something with it—that is, we want to process it. The part of a computer 
that is responsible for processing data is the central processing unit (CPU). This device, which 
is also sometimes called a processor , consists of electronic switches arranged to perform sim -
ple logical, arithmetic, and control operations. The CPU executes an algorithm by fetching its 
binary instructions from memory, decoding them, and executing them. Executing an instruc -
tion might involve fetching other binary information—the data—from memory as well.
The processor can locate data in a computer’s primary memory very quickly. However, these 
data exist only as long as electric power comes into the computer. If the power fails or is turned 
off, the data in primary memory are lost. Clearly, a more permanent type of memory is needed 
to preserve data. This more permanent type of memory is called external  or  secondary 
 memory , and it comes in several forms. Magnetic storage media , such as tapes and hard 
disks, allow bit patterns to be stored as patterns on a magnetic field. Semiconductor storage 
media , such as flash memory sticks, perform much the same function with a different technol -
ogy, as do optical storage media , such as CDs and DVDs. Some of these secondary storage 
media can hold much larger quantities of information than the internal memory of a computer.
Computer Software
You have learned that a computer is a general-purpose problem-solving machine. To 
solve any computable problem, a computer must be capable of executing any algorithm. 
Because it is impossible to anticipate all of the problems for which there are  algorithmic 
solutions, there is no way to “hardwire” all potential algorithms into a computer’s 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

8   Introduction
CHAPTER 1hardware. Instead, we build some basic operations into the hardware’s processor and 
require any algorithm to use them. The algorithms are converted to binary form and then 
loaded, with their data, into the computer’s memory. The processor can then execute the 
algorithms’ instructions by running the hardware’s more basic operations.
Any programs that are stored in memory so that they can be executed later are called soft-
ware. A program stored in computer memory must be represented in binary digits, which 
is also known as machine code . Loading machine code into computer memory one digit at 
a time would be a tedious, error-prone task for human beings. It would be convenient if we 
could automate this process to get it right every time. For this reason, computer scientists 
have developed another program, called a loader , to perform this task. A loader takes a set 
of machine language instructions as input and loads them into the appropriate memory 
locations. When the loader is finished, the machine language program is ready to execute. 
Obviously, the loader cannot load itself into memory, so this is one of those algorithms that 
must be hardwired into the computer.
Now that a loader exists, we can load and execute other programs that make the develop -
ment, execution, and management of programs easier. This type of software is called  system 
software . The most important example of system software is a computer’s  operating system . 
You are probably already familiar with at least one of the most popular operating systems, 
such as Linux, Apple’s macOS, and Microsoft’s Windows. An operating system is responsible 
for managing and scheduling several concurrently running programs. It also manages the 
computer’s memory, including the external storage, and manages communications between 
the CPU, the input/output devices, and other computers on a network. An important part 
of any operating system is its file system , which allows human users to organize their data 
and programs in permanent storage. Another important function of an operating system is 
to provide user interfaces —that is, ways for the human user to interact with the computer’s 
software. A terminal-based interface  accepts inputs from a keyboard and displays text out -
put on a monitor screen. A graphical user interface (GUI)  organizes the monitor screen 
around the metaphor of a desktop, with windows containing icons for folders, files, and appli -
cations. This type of user interface also allows the user to manipulate images with a pointing 
device such as a mouse. A touchscreen interface  supports more direct manipulation of 
these visual elements with gestures such as pinches and swipes of the user’s fingers. Devices 
that respond verbally and in other ways to verbal commands are also becoming widespread.
Another major type of software is called applications software , or simply apps. An 
 application is a program that is designed for a specific task, such as editing a document or 
displaying a Web page. Applications include Web browsers, word processors, spreadsheets, 
database managers, graphic design packages, music production systems, and games, among 
millions of others. As you begin learning to write computer programs, you will focus on 
writing simple applications.
As you have learned, computer hardware can execute only instructions that are written in 
binary form—that is, in machine language. Writing a machine language program, however, 
would be an extremely tedious, error-prone task. To ease the process of writing computer 
programs, computer scientists have developed high-level programming languages  for 
expressing algorithms. These languages resemble English and allow the author to express 
algorithms in a form that other people can understand.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

9A Not-So-Brief History of Computing Systems
A programmer typically starts by writing high-level language statements in a text editor . 
The programmer then runs another program called a translator  to convert the high-level 
program code into executable code. Because it is possible for a programmer to make gram-
matical mistakes even when writing high-level code, the translator checks for  syntax errors  
before it completes the translation process. If it detects any of these errors, the translator 
alerts the programmer via error messages. The programmer then has to revise the program. 
If the translation process succeeds without a syntax error, the program can be executed 
by the run-time system . The run-time system might execute the program directly on the 
hardware or run yet another program called an interpreter  or virtual machine  to execute 
the program. Figure 1-3 shows the steps and software used in the  coding process.
Figure 1-3  Software used in the coding processCreate high-levellanguage programUser inputsOther error messagesSyntax error messages
Program
outputsText editorTranslator
Run-time
system
Exercises
1. List two examples of input devices and two examples of output devices.
2. What does the central processing unit (CPU) do?
3. How is information represented in hardware memory?
4. What is the difference between a terminal-based interface and a graphical user interface?
5. What role do translators play in the programming process?
A Not-So-Brief History of Computing Systems
Now that we have in mind some of the basic ideas of computing and computer systems, 
let’s take a moment to examine how they have taken shape in history. Figure 1-4 summa-
rizes some of the major developments in the history of computing. The discussion that 
 follows provides more details about these developments.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

10   Introduction
CHAPTER 1Approximate 
Dates Major Developments
Before 1800 tMathematicians discover and use algorithms
tAbacus used as a calculating aid
tFirst mechanical calculators built by Pascal and Leibniz
19th Century tJacquard’s loom
tBabbage’s Analytical Engine
tBoole’s system of logic
tHollerith’s punch card machine
1930s tTuring publishes results on computability
tShannon’s theory of information and digital switching
1940s tFirst electronic digital computers
1950s tFirst symbolic programming languages
tTransistors make computers smaller, faster, more durable, and less 
expensive
tEmergence of data processing applications
1960–1975 tIntegrated circuits accelerate the miniaturization of hardware
tFirst minicomputers
tTime-sharing operating systems
tInteractive user interfaces with keyboard and monitor
tProliferation of high-level programming languages
tEmergence of a software industry and the academic study of 
 computer science
1975–1990 tFirst microcomputers and mass-produced personal computers
tGraphical user interfaces become widespread
tNetworks and the Internet
1990–2000 tOptical storage for multimedia applications, images, sound,  
and video
tWorld Wide Web, Web applications, and e-commerce
tLaptops
2000–present tWireless computing, smartphones, and mobile applications
tComputers embedded and networked in an enormous variety of cars, 
household appliances, and industrial equipment
tSocial networking, use of big data in finance and commerce
tDigital streaming of music and video
Figure 1-4  Summary of major developments in the history of computing
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

11A Not-So-Brief History of Computing Systems
Before Electronic Digital Computers
Ancient mathematicians developed the first algorithms. The word “algorithm” comes from 
the name of a Persian mathematician, Muhammad ibn Musa al-Khwarizmi, who wrote 
several mathematics textbooks in the ninth century. About 2,300 years ago, the Greek 
mathematician Euclid, the inventor of geometry, developed an algorithm for computing the 
greatest common divisor of two numbers.
A device known as the abacus  also appeared in ancient times. The abacus helped people 
perform simple arithmetic. Users calculated sums and differences by sliding beads on a grid 
of wires (see Figure 1-5a). The configuration of beads on the abacus served as the data.
[a] Abacus Image © Lim ChewHow, 2008. Used under 
license from Shutterstock.com.
Figure 1-5  Some early computing devices
[b] Pascal’s Calculator Image © Mary Evans/Photo Researchers, Inc.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

12   Introduction
CHAPTER 1
In the seventeenth century, the French mathematician Blaise Pascal (1623–1662) built 
one of the first mechanical devices to automate the process of addition (see Figure 1-5b). 
The addition operation was embedded in the configuration of gears within the machine. 
The user entered the two numbers to be added by rotating some wheels. The sum or out-
put number appeared on another rotating wheel. The German mathematician Gottfried 
 Wilhelm Leibniz (1646–1716) built another mechanical calculator that included other 
arithmetic functions such as multiplication. Leibniz, who with Newton also invented cal-
culus, went on to propose the idea of computing with symbols as one of our most basic and 
general intellectual activities. He argued for a universal language in which one could solve 
any problem by calculating.
Early in the nineteenth century, the French engineer Joseph-Marie Jacquard (1752–1834) 
designed and constructed a machine that automated the process of weaving (see Figure 1-5c). 
Until then, each row in a weaving pattern had to be set up by hand, a quite tedious, error-
prone process. Jacquard’s loom was designed to accept input in the form of a set of punched 
cards. Each card described a row in a pattern of cloth. Although it was still an entirely 
mechanical device, Jacquard’s loom possessed something that previous devices had lacked—
the ability to execute an algorithm automatically. The set of cards expressed the algorithm or 
set of instructions that controlled the behavior of the loom. If the loom operator wanted to 
produce a different pattern, he just had to run the machine with a different set of cards.
[c] Jacquard’s Loom Image © Roger Viollet/Getty Images
Figure 1-5  (Continued )
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

13A Not-So-Brief History of Computing Systems
The British mathematician Charles Babbage (1792–1871) took the concept of a program-
mable computer a step further by designing a model of a machine that, conceptually, bore 
a striking resemblance to a modern general-purpose computer. Babbage conceived his 
machine, which he called the Analytical Engine, as a mechanical device. His design called 
for four functional parts: a mill to perform arithmetic operations, a store to hold data and 
a program, an operator to run the instructions from punched cards, and an output to pro-
duce the results on punched cards. Sadly, Babbage’s computer was never built. The project 
perished for lack of funds near the time when Babbage himself passed away.
In the last two decades of the nineteenth century, a U.S. Census Bureau statistician named 
Herman Hollerith (1860–1929) developed a machine that automated data processing for 
the U.S. Census. Hollerith’s machine, which had the same component parts as Babbage’s 
Analytical Engine, simply accepted a set of punched cards as input and then tallied and 
sorted the cards. His machine greatly shortened the time it took to produce statistical 
results on the U.S. population. Government and business organizations seeking to automate 
their data processing quickly adopted Hollerith’s punched card machines. Hollerith was 
also one of the founders of a company that eventually became IBM (International Business 
Machines).
Also in the nineteenth century, the British secondary school teacher George Boole 
(1815–1864) developed a system of logic. This system consisted of a pair of values, TRUE 
and FALSE, and a set of three primitive operations on these values, AND, OR, and NOT. 
Boolean logic eventually became the basis for designing the electronic circuitry to process 
binary information.
A half a century later, in the 1930s, the British mathematician Alan Turing (1912–1954) 
explored the theoretical foundations and limits of algorithms and computation. Turing’s 
essential contributions were to develop the concept of a universal machine that could be 
specialized to solve any computable problems, and to demonstrate that some problems are 
unsolvable by computers.
The First Electronic Digital Computers (1940–1950)
In the late 1930s, Claude Shannon (1916–2001), a mathematician and electrical engineer at 
MIT, wrote a classic paper titled “ A Symbolic Analysis of Relay and Switching Circuits. ” In 
this paper, he showed how operations and information in other systems, such as arithmetic, 
could be reduced to Boolean logic and then to hardware. For example, if the Boolean val-
ues TRUE and FALSE were written as the binary digits 1 and 0, one could write a sequence 
of logical operations that computes the sum of two strings of binary digits. All that was 
required to build an electronic digital computer was the ability to represent binary digits as 
on/off switches and to represent the logical operations in other circuitry.
The needs of the combatants in World War II pushed the development of computer hard-
ware into high gear. Several teams of scientists and engineers in the United States,  England, 
and Germany independently created the first generation of general-purpose digital elec-
tronic computers during the 1940s. All of these scientists and engineers used  Shannon’s 
innovation of expressing binary digits and logical operations in terms of electronic 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

14   Introduction
CHAPTER 1switching devices. Among these groups was a team at Harvard University under the direc-
tion of Howard Aiken. Their computer, called the Mark I, became operational in 1944 and 
did mathematical work for the U.S. Navy during the war. The Mark I was considered an 
electromechanical device, because it used a combination of magnets, relays, and gears to 
store and process data.
Another team under J. Presper Eckert and John Mauchly, at the University of Pennsylvania, 
produced a computer called the ENIAC (Electronic Numerical Integrator and Calculator). 
The ENIAC calculated ballistics tables for the artillery of the U.S. Army toward the end of 
the war. Because the ENIAC used entirely electronic components, it was almost a thousand 
times faster than the Mark I.
Two other electronic digital computers were completed a bit earlier than the ENIAC. They 
were the ABC (Atanasoff-Berry Computer), built by John Atanasoff and Clifford Berry at 
Iowa State University in 1942, and the Colossus, constructed by a group working under 
Alan Turing in England in 1943. The ABC was created to solve systems of simultaneous 
linear equations. Although the ABC’s function was much narrower than that of the ENIAC, 
the ABC is now regarded as the first electronic digital computer. The Colossus, whose exis-
tence had been top secret until recently, was used to crack the powerful German Enigma 
code during the war.
The first electronic digital computers, sometimes called mainframe computers , consisted 
of vacuum tubes, wires, and plugs, and filled entire rooms. Although they were much 
faster than people at computing, by our own current standards, they were extraordinarily 
slow and prone to breakdown. Moreover, the early computers were extremely difficult to 
program. To enter or modify a program, a team of workers had to rearrange the connec-
tions among the vacuum tubes by unplugging and replugging the wires. Each program was 
loaded by literally hardwiring it into the computer. With thousands of wires involved, it was 
easy to make a mistake.
The memory of these first computers stored only data, not the program that processed 
the data. As we have seen, the idea of a stored program first appeared 100 years earlier in 
Jacquard’s loom and in Babbage’s design for the Analytical Engine. In 1946, John von Neu-
mann realized that the instructions of the programs could also be stored in binary form in 
an electronic digital computer’s memory. His research group at Princeton developed one of 
the first modern stored-program computers.
Although the size, speed, and applications of computers have changed dramatically since 
those early days, the basic architecture and design of the electronic digital computer have 
remained remarkably stable.
The First Programming Languages (1950–1965)
The typical computer user now runs many programs, made up of millions of lines of code, 
that perform what would have seemed like magical tasks 30 or 40 years ago. But the first 
digital electronic computers had no software as we think of it today. The machine code for 
a few relatively simple and small applications had to be loaded by hand. As the demand for 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

15A Not-So-Brief History of Computing Systems
larger and more complex applications grew, so did the need for tools to expedite the pro-
gramming process.
In the early 1950s, computer scientists realized that a symbolic notation could be used 
instead of machine code, and the first assembly languages  appeared. The programmers 
would enter mnemonic codes for operations, such as ADD and OUTPUT, and for data 
variables, such as SALARY and RATE, at a keypunch machine . The keystrokes punched 
a set of holes in a small card for each instruction. The programmers then carried their 
stacks of cards to a system operator, who placed them in a device called a card reader . This 
device translated the holes in the cards to patterns in the computer’s memory. A program 
called an assembler  then translated the application programs in memory to machine code, 
and they were executed.
Programming in assembly language was a definite improvement over programming in 
machine code. The symbolic notation used in assembly languages was easier for people 
to read and understand. Another advantage was that the assembler could catch some 
programming errors before the program was actually executed. However, the symbolic 
notation still appeared a bit arcane when compared with the notations of conventional 
mathematics. To remedy this problem, John Backus, a programmer working for IBM, devel-
oped FORTRAN (Formula Translation Language) in 1954. Programmers, many of whom 
were mathematicians, scientists, and engineers, could now use conventional algebraic nota-
tion. FORTRAN programmers still entered their programs on a keypunch machine, but the 
computer executed them after they were translated to machine code by a compiler .
FORTRAN was considered ideal for numerical and scientific applications. However, 
expressing the kind of data used in data processing—in particular, textual information—
was difficult. For example, FORTRAN was not practical for processing  information that 
included people’s names, addresses, Social Security numbers, and the financial data of 
corporations and other institutions. In the early 1960s, a team led by Rear Admiral Grace 
 Murray Hopper developed COBOL (Common Business Oriented Language) for data 
 processing in the U.S. government. Banks, insurance companies, and other  institutions 
were quick to adopt its use in data-processing applications.
Also in the late 1950s and early 1960s, John McCarthy, a computer scientist at MIT, 
developed a powerful and elegant notation called LISP (List Processing) for expressing 
computations. Based on a theory of recursive functions (a subject covered in Chapter 6), 
LISP captured the essence of symbolic information processing. A student of McCarthy’s, 
Steve “Slug” Russell, coded the first interpreter  for LISP in 1960. The interpreter accepted 
LISP expressions directly as inputs, evaluated them, and printed their results. In its early 
days, LISP was used primarily for laboratory experiments in an area of research known as 
 artificial intelligence . More recently, LISP has been touted as an ideal language for solving 
any difficult or complex problems.
Although they were among the first high-level programming languages, FORTRAN and 
LISP have survived for decades. They have undergone many modifications to improve their 
capabilities and have served as models for the development of many other programming 
languages. COBOL, by contrast, is no longer in active use but has survived mainly in the 
form of legacy programs that must still be maintained.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

16   Introduction
CHAPTER 1These new, high-level programming languages had one feature in common: abstraction . In 
science or any other area of enquiry, an abstraction allows human beings to reduce complex 
ideas or entities to simpler ones. For example, a set of ten assembly language instructions 
might be replaced with an equivalent algebraic expression that consists of only five sym-
bols in FORTRAN. Put another way, any time you can say more with less, you are using an 
abstraction. The use of abstraction is also found in other areas of computing, such as hard-
ware design and information architecture. The complexities don’t actually go away, but the 
abstractions hide them from view. The suppression of distracting complexity with abstrac-
tions allows computer scientists to conceptualize, design, and build ever more sophisticated 
and complex systems.
Integrated Circuits, Interaction, and Timesharing (1965–1975)
In the late 1950s, the vacuum tube gave way to the transistor  as the mechanism for imple-
menting the electronic switches in computer hardware. As a solid-state device , the transis-
tor was much smaller, more reliable, more durable, and less expensive to manufacture than 
a vacuum tube. Consequently, the hardware components of computers generally became 
smaller in physical size, more reliable, and less expensive. The smaller and more numerous 
the switches became, the faster the processing and the greater the capacity of memory to 
store information.
The development of the integrated circuit  in the early 1960s allowed computer engineers 
to build ever smaller, faster, and less-expensive computer hardware components. They 
 perfected a process of photographically etching transistors and other solid-state compo-
nents onto very thin wafers of silicon, leaving an entire processor and memory on a single 
chip. In 1965, Gordon Moore, one of the founders of the computer chip manufacturer Intel, 
made a prediction that came to be known as Moore’s Law . This prediction states that the 
processing speed and storage capacity of hardware will increase and its cost will decrease 
by approximately a factor of 2 every 18 months. This trend has held true for more than  
50 years. For example, in 1965 there were about 50 electrical components on a chip, 
whereas by 2000, a chip could hold over 40 million components. Without the integrated 
circuit, men would not have gone to the moon in 1969, and we would not have the power-
ful and inexpensive handheld devices that we now use on a daily basis.
Minicomputers the size of a large office desk appeared in the 1960s. The means of develop-
ing and running programs also were changing. Until then, a computer was typically located 
in a restricted area with a single human operator. Programmers composed their programs 
on keypunch machines in another room or building. They then delivered their stacks of 
cards to the computer operator, who loaded them into a card reader, and compiled and 
ran the programs in sequence on the computer. Programmers then returned to pick up the 
output results, in the form of new stacks of cards or printouts. This mode of operation, 
also called batch processing , might cause a programmer to wait days for results, including 
error messages.
The increases in processing speed and memory capacity enabled computer scientists to develop 
the first time-sharing operating system. John McCarthy, the creator of the programming  
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

17A Not-So-Brief History of Computing Systems
language LISP , recognized that a program could automate many of the functions performed by 
the human system operator. When memory, including magnetic secondary storage, became 
large enough to hold several users’ programs at the same time, they could be scheduled for 
 concurrent processing . Each process associated with a program would run for a slice of time 
and then yield the CPU to another process. All of the active processes would repeatedly cycle 
for a turn with the CPU until they finished.
Several users could now run their own programs simultaneously by entering commands 
at separate terminals connected to a single computer. As processor speeds continued to 
increase, each user gained the illusion that a time-sharing computer system belonged 
entirely to him or her.
By the late 1960s, programmers could enter program input at a terminal and also see pro-
gram output immediately displayed on a CRT (Cathode Ray Tube) screen . Compared to its 
predecessors, this new computer system was both highly interactive and much more acces-
sible to its users.
Many relatively small and medium-sized institutions, such as universities, were now able to 
afford computers. These machines were used not only for data processing and engineering 
applications but also for teaching and research in the new and rapidly growing field of com-
puter science.
Personal Computing and Networks (1975–1990)
In the mid-1960s, Douglas Engelbart, a computer scientist working at the Stanford 
Research Institute (SRI), first saw one of the ultimate implications of Moore’s Law: even-
tually, perhaps within a generation, hardware components would become small enough 
and affordable enough to mass produce an individual computer for every human being. 
What form would these personal computers take, and how would their owners use them? 
Two decades earlier, in 1945, Engelbart had read an article in The Atlantic Monthly  titled 
“ As We May Think” that had already posed this question and offered some answers. The 
author, Vannevar Bush, a scientist at MIT, predicted that computing devices would serve as 
repositories of information and, ultimately, of all human knowledge. Owners of computing 
devices would consult this information by browsing through it with pointing devices, and 
they would contribute information to the knowledge base almost at will. Engelbart agreed 
that the primary purpose of the personal computer would be to augment the human intel-
lect, and he spent the rest of his career designing computer systems that would accomplish 
this goal.
During the late 1960s, Engelbart built the first pointing device, or mouse. He also designed 
software to represent windows, icons, and pull-down menus on a bit-mapped display 
screen . He demonstrated that a computer user could not only enter text at the keyboard 
but could also directly manipulate the icons that represent files, folders, and computer 
applications on the screen.
But for Engelbart, personal computing did not mean computing in isolation. He partici -
pated in the first experiment to connect computers in a network, and he believed that 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

18   Introduction
CHAPTER 1soon people would use computers to communicate, share information, and collaborate on 
team projects.
Engelbart developed his first experimental system, which he called NLS (oNLine System) 
Augment, on a minicomputer at SRI. In the early 1970s, he moved to Xerox PARC (Palo 
Alto Research Center) and worked with a team under Alan Kay to develop the first desktop 
computer system. Called the Alto, this system had many of the features of Engelbart’s Aug-
ment, as well as e-mail and a functioning hypertext (a forerunner of the World Wide Web). 
Kay’s group also developed a programming language called Smalltalk, which was designed 
to create programs for the new computer and to teach programming to children. Kay’s goal 
was to develop a personal computer the size of a large notebook, which he called the Dyna-
book. Unfortunately for Xerox, the company’s management had more interest in photocopy 
machines than in the work of Kay’s visionary research group. However, a young entrepre-
neur named Steve Jobs visited the Xerox lab and saw the Alto in action. Almost a decade 
later, in 1984, Apple Computer, the now-famous company founded by Steve Jobs, brought 
forth the Macintosh, the first successful mass-produced personal computer with a graphical 
user interface.
While Kay’s group was busy building the computer system of the future in their research 
lab, dozens of hobbyists gathered near San Francisco to found the Homebrew Computer 
Club, the first personal computer users group. They met to share ideas, programs, hard-
ware, and applications for personal computing. The first mass-produced personal com-
puter, the Altair, appeared in 1975. The Altair contained Intel’s 8080 processor, the first 
microprocessor  chip. But from the outside, the Altair looked and behaved more like a 
miniature version of the early computers than the Alto. Programs and their input had to 
be entered by flipping switches, and output was displayed by a set of lights. However, the 
Altair was small enough for personal computing enthusiasts to carry home, and Input/ 
Output devices eventually were invented to support the processing of text and sound.
The Osborne and the Kaypro were among the first mass-produced interactive personal 
computers. They boasted tiny display screens and keyboards, with floppy disk drives for 
loading system software, applications software, and users’ data files. Early personal com-
puting applications were word processors, spreadsheets, and games such as Pac-Man  and 
Spacewar! . These computers also ran CP/M (Control Program for Microcomputers), the 
first PC-based operating system.
In the early 1980s a college dropout named Bill Gates and his partner Paul Allen built their 
own operating system software, which they called MS-DOS (Microsoft Disk Operating 
System). They then arranged a deal with the giant computer manufacturer IBM to sup -
ply MS-DOS for the new line of PCs that the company intended to mass produce. This 
deal proved to be a very advantageous one for Gates’s company, Microsoft. Not only did 
 Microsoft receive a fee for each computer sold but it also got a head start on supplying 
applications software that would run on its operating system. Brisk sales of the IBM PC 
and its “clones” to individuals and institutions quickly made MS-DOS the world’s most 
widely used operating system. Within a few years, Gates and Allen had become billionaires, 
and within a decade, Gates had become the world’s richest man, a position he held for  
13 straight years.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

19A Not-So-Brief History of Computing Systems
Also in the 1970s, the U.S. government began to support the development of a network that 
would connect computers at military installations and research universities. The first such 
network, called ARPANET (Advanced Research Projects Agency Network), connected four 
computers at SRI, UCLA (University of California at Los Angeles), UC Santa Barbara, and 
the University of Utah. Bob Metcalfe, a researcher associated with Kay’s group at Xerox, 
developed a software protocol called Ethernet for operating a network of computers. Ether-
net allowed computers to communicate in a local area network (LAN) within an organiza-
tion and also with computers in other organizations via a wide area network (WAN). By the 
mid-1980s, the ARPANET had grown into what we now call the Internet, connecting com-
puters owned by large institutions, small organizations, and individuals all over the world.
Consultation, Communication, and E-Commerce (1990–2000)
In the 1990s, computer hardware costs continued to plummet, and processing speed and 
memory capacity skyrocketed. Optical storage media, such as compact discs (CDs) and dig-
ital video discs (DVDs), were developed for mass storage. The digitizing and computational 
processing of images, sound, and video became feasible and widespread. By the end of the 
decade, entire movies were being shot or constructed and played back using digital devices. 
Toy Story , the first full-length animated feature film produced entirely by a computer, 
appeared in 1995. The capacity to create lifelike three-dimensional animations of whole 
environments led to a new technology called virtual reality . New devices appeared, such as 
flatbed scanners and digital cameras, which could be used along with the more traditional 
microphone and speakers to support the input, digitizing, and output of almost any type of 
information.
Desktop and laptop computers now not only perform useful work but also give their users 
new means of personal expression. This decade saw the rise of computers as communi -
cation tools, with e-mail, instant messaging, bulletin boards, chat rooms, and the World 
Wide Web.
Perhaps the most interesting story from this period concerns Tim Berners-Lee, the cre-
ator of the World Wide Web. In the late 1980s, Berners-Lee, a theoretical physicist doing 
research at the CERN Institute in Geneva, Switzerland, began to develop some ideas for 
using computers to share information. Computer engineers had been linking comput-
ers to networks for several years, and it was already common in research communities to 
exchange files and send and receive e-mail around the world. However, the vast differences 
in hardware, operating systems, file formats, and applications still made it difficult for users 
who were not adept at programming to access and share this information. Berners-Lee was 
interested in creating a common medium for sharing information that would be easy to use, 
not only for scientists but also for any other person capable of manipulating a keyboard and 
mouse and viewing the information on a monitor.
Berners-Lee was familiar with Vannevar Bush’s vision of a web-like consultation system, 
Engelbart’s work on NLS Augment, and also with the first widely available hypertext sys-
tems. One of these systems, Apple Computer’s HyperCard, broadened the scope of hyper-
text to hypermedia . HyperCard allowed authors to organize not just text but also images, 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

20   Introduction
CHAPTER 1sound, video, and executable applications into webs of linked information. However, a 
HyperCard database sat only on standalone computers; the links could not carry Hyper-
Card data from one computer to another. Furthermore, the supporting software ran only 
on Apple’s computers.
Berners-Lee realized that networks could extend the reach of a hypermedia system to any 
computers connected to the net, making their information available worldwide. To preserve 
its independence from particular operating systems, the new medium would need to have 
universal standards for distributing and presenting the information. To ensure this neu-
trality and independence, no private corporation or individual government could own the 
medium and dictate the standards.
Berners-Lee built the software for this new medium, which we now call the World Wide 
Web, in 1992. The software used many of the existing mechanisms for transmitting 
 information over the Internet. People contribute information to the Web by publishing 
files on computers known as Web servers . The Web server software on these computers is 
responsible for answering requests for viewing the information stored on the Web server. 
To view information on the Web, people use software called a Web browser . In response to 
a user’s commands, a Web browser sends a request for information across the Internet to  
the appropriate Web server. The server responds by sending the information back to the 
browser’s computer, called a Web client , where it is displayed or rendered in the browser.
Although Berners-Lee wrote the first Web server and Web browser software, he made two 
other even more important contributions. First, he designed a set of rules, called HTTP 
(Hypertext Transfer Protocol), which allows any server and browser to talk to each other. 
Second, he designed a language, HTML (Hypertext Markup Language), which allows 
browsers to structure the information to be displayed on Web pages. He then made all of 
these resources available to anyone for free.
Berners-Lee’s invention and gift of this universal information medium is a truly remark-
able achievement. Today there are millions of Web servers in operation around the world. 
Anyone with the appropriate training and resources—companies, government, nonprofit 
organizations, and private individuals—can start up a new Web server or obtain space on 
one. Web browser software now runs not only on desktop and laptop computers but also 
on handheld devices such as cell phones.
The growth of the Internet, the Web, and related software technologies also transformed 
manufacturing, retail sales, and finance in the latter half of this decade. Computer-  
supported automation dramatically increased productivity (while eliminating high-paying 
jobs for many people). Firms established and refined the chains of production and distribu-
tion of goods, from raw materials to finished products to retail sales, which were increas-
ingly cost-effective and global in scope. Computer technology facilitated in large part the 
spread of giant big-box stores like Walmart and the rise of online stores like Amazon (while 
driving many local retailers out of business and creating a workforce of part-timers without 
benefits).
The technology that made online stores pervasive, called Web applications , presented 
a revolution in the way in which software services were delivered to people. Instead of 
purchasing and running software for specific applications to run on one’s own computer, 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

21A Not-So-Brief History of Computing Systems
one could obtain access to a specific service through a Web browser. The Web application 
providing this service ran on a remote computer or server  located at the provider’s place 
of business. The Web browser played the role of the client , front end, or user interface for 
millions of users to access the same server application for a given service. Client/server 
applications  had already been in use for e-mail, buttletin boards, and chat rooms on the 
Internet, so this technology was simply deployed on the Web when it became available.
The final major development of this decade took place in a computer lab at Stanford Uni-
versity, where two graduate students, Sergey Brin and Larry Page, developed algorithms for 
indexing and searching the Web. The outcome of their work added a new verb to the dic-
tionary: to Google. Today, much of the world’s economy and research relies upon Google’s 
various search platforms.
Mobile Applications and Ubiquitous Computing (2000–present)
As the previous millennium drew to a close, computer hardware continued to shrink in 
size and cost, and to provide more memory and greater processing speed. Laptop comput-
ers became smaller, faster, and more affordable to millions of people. The first handheld 
computing devices, called personal digital assistants ( PDAs) began to appear. Applications 
for these devices were limited to simple video games, address books, to-do lists, and note 
taking, and they had to be connected via cable to a laptop or desktop computer to transfer 
information.
Meanwhile, cellular technology became widespread, with millions of people beginning 
to use the first cell phones. These devices, which allowed calls to be made from a simple 
mechanical keypad, were “dumb” when compared to today’s smartphones. But cellular 
technology provided the basis for what was soon to come. At about the same time, wire-
less technology began to allow computers to communicate through the air to a base station 
with an Internet connection. The conditions for mobile and ubiquitous computing were 
now in place, awaiting only the kinds of devices and apps that would make them useful and 
popular.
No one foresaw the types of devices and applications that mobile computing would make 
possible better than Steve Jobs (the founder of Apple Computer, mentioned earlier). Dur -
ing the final dozen years of his life, Jobs brought forward from Apple several devices and 
technologies that revolutionized not only computing but also the way in which people 
engaged in cultural pursuits. The devices were the iPod, which began as a digital music 
player but evolved into a handheld general-purpose computing device; the iPhone, which 
added cellular phone technology to the iPod’s capabilities; and the iPad, which realized 
Alan Kay’s dreams of a personal notebook computer. All of these devices utilized touch -
screen and voice recognition technology, which eliminated the need for bulky mechani -
cal keypads.
The associated software technologies came in the form of Apple’s iLife suite, a set of 
applications that allowed users to organize various types of media (music, photos, video, 
and books); and Apple’s iTunes, iBooks, and App Stores, vendor sites that allowed devel -
opers to market mobile media and applications. The Web browser that for a decade had 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

22   Introduction
CHAPTER 1given users access to Web apps became just another type of app in the larger world of 
mobile computing.
The new millennium has seen another major addition to the digital landscape: social net-
working applications. Although various Internet forums, such as chatrooms and bulletin 
board systems, had been in use for a couple of decades, their use was not widespread. In 
2004, Mark Zuckerberg, a student at Harvard University, changed all that when he launched 
Facebook from his college dorm room. The application allowed students to join a network 
to share their profiles, post messages, photos, and videos, and generally communicate as 
“friends. ” Participation in this network rapidly spread to include more than a billion users. 
Social networking technology now includes many other variations, as exemplified by 
 LinkedIn, Twitter, Tumblr, Flickr, and Instagram.
We conclude this not-so-brief overview by mentioning the rise of a technology known 
as big data . Governments, businesses, and hackers continually monitor Internet traffic 
for various purposes. This “clickstream” can be “mined” to learn users’ preferences and 
interests, to better serve them, to exploit them, or to spy on them. For example, an online 
store might advertise a product on a person’s Facebook page immediately after that person 
viewed a similar product while shopping online. Researchers in the field of data science  
have created algorithms that process massive amounts of data to discover trends and pre-
dict outcomes.
To summarize this not so-brief history, one trend ties the last several decades of comput-
ing together: rapid progress. Processes and things have become automated, programmable, 
smaller, faster, highly interconnected, and easily visualized and interpreted.
If you want to learn more about the history of computing, consult the sources listed at the 
end of this chapter. We now turn to an introduction to programming in Python.
Getting Started with Python Programming
Guido van Rossum invented the Python programming language in the early 1990s. Python 
is a high-level, general-purpose programming language for solving problems on modern 
computer systems. The language and many supporting tools are free, and Python programs 
can run on any operating system. You can download Python, its documentation, and related 
materials from www.python.org. Instructions for downloading and installing Python are in 
Appendix A. In this section, we show you how to create and run simple Python programs.
Running Code in the Interactive Shell
Python is an interpreted language, and you can run simple Python expressions and state-
ments in an interactive programming environment called the shell. The easiest way to open 
a Python shell is to launch the IDLE (Integrated DeveLopment Environment). This is an 
integrated program development environment that comes with the Python installation. 
When you do this, a window named Python Shell  opens. Figure 1-6 shows a shell  window 
on macOS. A shell window running on a Windows system or a Linux system should look 
similar, if not identical, to this one. Note that the version of Python appearing in this 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

23Getting Started with Python Programming
A shell window contains an opening message followed by the special symbol >>>, called 
a shell prompt. The cursor at the shell prompt waits for you to enter a Python command. 
Note that you can get immediate help by entering help at the shell prompt or selecting 
Help  from the window’s drop-down menu.
When you enter an expression or statement, Python evaluates it and displays its result, if 
there is one, followed by a new prompt. The next few lines show the evaluation of several 
expressions and statements.
>>> 3 + 4                    # Simple arithmetic
7
>>> 3 # The value of 3 is
3
>>> "Python is really cool!" # Use a string for text
'Python is really cool!'
>>> name  = "Ken Lambert" # Give a variable a value
>>> name # The value of name is
'Ken Lambert'
>>> "Hi there, "  + name # Create some new text
'Hi there, Ken Lambert'
>>> print('Hi there' ) # Output some text
Hi there
>>> print("Hi there," , name)    # Output two values
Hi there, Ken Lambert
Note the use of colors in the Python code. The IDLE programming environment uses color-
coding to help the reader pick out different elements in the code. In this example, the items 
within quotation marks are in green, the names of standard functions are in purple, program 
comments are in red, and the responses of IDLE to user commands are in blue. The remaining 
code is in black. Table 1-1 lists the color-coding scheme used in all program code in this book.Figure 1-6  Python shell window
screenshot is 3.6.1. This book assumes that you will use Python 3 rather than Python 2. 
There are substantial differences between the two versions, and many examples used in this 
book will not work with Python 2.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

24   Introduction
CHAPTER 1
The Python shell is useful for experimenting with short expressions or statements to learn 
new features of the language, as well as for consulting documentation on the language. To 
quit the Python shell, you can either select the window’s close box or press the Control 1D 
key combination.
The means of developing more complex and interesting programs are examined in the rest 
of this section.
Input, Processing, and Output
Most useful programs accept inputs from some source, process these inputs, and then 
finally output results to some destination. In terminal-based interactive programs, the input 
source is the keyboard, and the output destination is the terminal display. The Python shell 
itself is such a program; its inputs are Python expressions or statements. Its processing 
evaluates these items. Its outputs are the results displayed in the shell.
The programmer can also force the output of a value by using the print function. The sim-
plest form for using this function looks like the following:
print(<expression>)
This example shows you the basic syntax  (or grammatical rule) for using the print func-
tion. The angle brackets (the < and > symbols) enclose a type of phrase. In actual Python 
code, you would replace this syntactic form, including the angle brackets, with an example 
of that type of phrase. In this case, <expression>  is shorthand for any Python expression, 
such as 3 + 4.Color Type of Element Examples
Black Inputs in the IDLE shell
Numbers
Operator symbols
Variable, function, and method references
Punctuation marks67, +, name, y = factorial(x)
Blue Outputs in the IDLE shell
Function, class, and method names in 
definitions'Ken Lambert' ,
def factorial (n)
Green Strings "Ken Lambert"
Orange Keywords def, if, while
Purple Built-in function names abs, round, int
Red Program comments
Error messages in the IDLE shell# Output the results
ZeroDivisionError: division 
by zero
Table 1-1  Color-coding of Python program elements in IDLE
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

25Getting Started with Python Programming
When running the print function, Python first evaluates the expression and then displays 
its value. In the example shown earlier, print was used to display some text. The following 
is another example:
>>> print ("Hi there" )
Hi there
In this example, the text "Hi there"  is the text that we want Python to display. In program-
ming terminology, this piece of text is referred to as a string . In Python code, a string is 
always enclosed in quotation marks. However, the print function displays a string without 
the quotation marks.
You can also write a print function that includes two or more expressions separated by 
commas. In such a case, the print function evaluates the expressions and displays their 
results, separated by single spaces, on one line. The syntax for a print statement with two 
or more expressions looks like the following:
print(<expression>,..., <expression>)
Note the ellipsis ( ...) in this syntax example. The ellipsis indicates that you could include 
multiple expressions after the first one. Whether it outputs one or multiple expressions, the 
print function always ends its output with a newline . In other words, it displays the values 
of the expressions, and then it moves the cursor to the next line on the console window.
To begin the next output on the same line as the previous one, you can place the expression 
end = "", which says “end the line with an empty string instead of a newline, ” at the end of 
the list of expressions, as follows:
print(<expression>, end = "")
As you create programs in Python, you’ll often want your programs to ask the user for 
input. You can do this by using the input function. This function causes the program to 
stop and wait for the user to enter a value from the keyboard. When the user presses the 
return or enter key, the function accepts the input value and makes it available to the pro-
gram. A program that receives an input value in this manner typically saves it for further 
processing.
The following example receives an input string from the user and saves it for further pro-
cessing. The user’s input is in black.
>>> name  = input("Enter your name: " )
Enter your name:  Ken Lambert
>>> name
'Ken Lambert'
>>> print(name)
Ken Lambert
>>>
The input function does the following:
1. Displays a prompt for the input. In this example, the prompt is "Enter your name: " .
2. Receives a string of keystrokes, called characters, entered at the keyboard and 
returns the string to the shell.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

26   Introduction
CHAPTER 1How does the input function know what to use as the prompt? The text in parenthe -
ses, "Enter your name: " , is an argument for the input function that tells it what to 
use for the prompt. An argument  is a piece of information that a function needs to do 
its work.
The string returned by the function in our example is saved by assigning it to the variable 
name. The form of an assignment statement with the input function is the following:
<variable identifier>  = input(<a string prompt>)
A variable identifier , or variable  for short, is just a name for a value. When a variable 
receives its value in an input statement, the variable then refers to this value. If the user 
enters the name "Ken Lambert"  in our last example, the value of the variable name can be 
viewed as follows:
>>> name
'Ken Lambert'
The input function always builds a string from the user’s keystrokes and returns it to 
the program. After inputting strings that represent numbers, the programmer must con-
vert them from strings to the appropriate numeric types. In Python, there are two type 
 conversion functions  for this purpose, called int (for integers) and float (for floating-
point numbers). The next session inputs two integers and displays their sum:
>>> first  = int(input("Enter the first number: " ))
Enter the first number:  23
>>> second  = int(input("Enter the second number: " ))
Enter the second number:  44
>>> print("The sum is" , first + second)
The sum is 67
Note that the int function is called with each result returned by the input function. The 
two numbers are added, and then their sum is output. Table 1-2 summarizes the functions 
introduced in this subsection.
Function What It Does
float(<a string of digits >)Converts a string of digits to a floating-point value.
int(<a string of digits>) Converts a string of digits to an integer value.
input(<a  string prompt >) Displays the string prompt and waits for keyboard input. 
Returns the string of characters entered by the user.
print(<expression>, 
...,<expression>)Evaluates the expressions and displays them, separated 
by one space, in the console window.
<string 1> + <string 2> Glues the two strings together and returns the result.
Table 1-2  Basic Python functions for input and output
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

27Getting Started with Python Programming
Editing, Saving, and Running a Script
While it is easy to try out short Python expressions and statements interactively at a shell 
prompt, it is more convenient to compose, edit, and save longer, more complex programs in 
files. We can then run these program files or scripts either within IDLE or from the operat-
ing system’s command prompt without opening IDLE. Script files are also the means by 
which Python programs are distributed to others. Most important, as you know from writ-
ing term papers, files allow you to save, safely and permanently, many hours of work.
To compose and execute programs in this manner, you perform the following steps:
1. Select the option New Window  from the File menu of the shell window.
2. In the new window, enter Python expressions or statements on separate lines, in the 
order in which you want Python to execute them.
3. At any point, you may save the file by selecting File/Save. If you do this, you should use 
a . py extension. For example, your first program file might be named  myprogram.py .
4. To run this file of code as a Python script, select Run Module  from the Run  menu 
or press the F5 key.
The command in Step 4 reads the code from the saved file and executes it. If Python exe-
cutes any print functions in the code, you will see the outputs as usual in the shell window. 
If the code requests any inputs, the interpreter will pause to allow you to enter them. Oth-
erwise, program execution continues invisibly behind the scenes. When the interpreter has 
finished executing the last instruction, it quits and returns you to the shell prompt.
Figure 1-7 shows an IDLE window containing a complete script that prompts the user for 
the width and height of a rectangle, computes its area, and outputs the result:
Figure 1-7  Python script in an IDLE window
When the script is run from the IDLE window, it produces the interaction with the user in 
the shell window shown in Figure 1-8.
This can be a slightly less interactive way of executing programs than entering them directly 
at Python’s interpreter prompt. However, running the script from the IDLE window will 
allow you to construct some complex programs, test them, and save them in program 
libraries  that you can reuse or share with others.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

28   Introduction
CHAPTER 1
Behind the Scenes: How Python Works
Whether you are running Python code as a script or interactively in a shell, the Python 
interpreter does a great deal of work to carry out the instructions in your program. This 
work can be broken into a series of steps, as shown in Figure 1-9.Figure 1-8  Interaction with a script in a shell window
Figure 1-9  Steps in interpreting a Python programPython codeUser inputs Other error messagesSyntax error messages
Program
outputsByte codeSyntax Checker
and Translator
Python Virtual
Machine (PVM)
1. The interpreter reads a Python expression or statement, also called the source 
code, and verifies that it is well formed. In this step, the interpreter behaves like a 
strict English teacher who rejects any sentence that does not adhere to the gram-
mar rules, or syntax, of the language. As soon as the interpreter encounters such an 
error, it halts translation with an error message.
2. If a Python expression is well formed, the interpreter then translates it to an equiva-
lent form in a low-level language called byte code . When the interpreter runs a 
script, it completely translates it to byte code.
3. This byte code is next sent to another software component, called the Python 
 virtual machine ( PVM), where it is executed. If another error occurs during this 
step, execution also halts with an error message.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

29Detecting and Correcting Syntax Errors
Detecting and Correcting Syntax Errors
Programmers inevitably make typographical errors when editing programs, and the Python 
interpreter will nearly always detect them. Such errors are called syntax errors. The term 
syntax  refers to the rules for forming sentences in a language. When Python encounters 
a syntax error in a program, it halts execution with an error message. The following ses-
sions with the Python shell show several types of syntax errors and the corresponding error 
messages:
>>> length  = int(input("Enter the length: " ))
Enter the length:  44
>>> print(lenth)
Traceback (most recent call last):
  File "<pyshell#l>", line 1, in <module>
NameError: name 'lenth' is not defined
The first statement assigns an input value to the variable length. The next statement 
attempts to print the value of the variable lenth. Python responds that this name is not 
defined. Although the programmer might have meant  to write the variable length, Python 
can read only what the programmer actually entered . This is a good example of the rule 
that a computer can read only the instructions it receives, not the instructions we intend to 
give it.
The next statement attempts to print the value of the correctly spelled variable. However, 
Python still generates an error message.
>>> print(length)
SyntaxError: unexpected indent
In this error message, Python explains that this line of code is unexpectedly indented. 
In fact, there is an extra space before the word print. Indentation is significant in 
Python code. Each line of code entered at a shell prompt or in a script must begin in 
the leftmost column, with no leading spaces. The only exception to this rule occurs in 
control statements and definitions, where nested statements must be indented one or 
more spaces.Exercises
1. Describe what happens when the programmer enters the string "Greetings!"  in 
the Python shell.
2. Write a line of code that prompts the user for his or her name and saves the user’s 
input in a variable called name.
3. Answer the question, What is a Python script?
4. Explain what goes on behind the scenes when your computer runs a Python 
program.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

30   Introduction
CHAPTER 1You might think that it would be painful to keep track of indentation in a program. How-
ever, in compensation, the Python language is much simpler than other programming lan-
guages. Consequently, there are fewer types of syntax errors to encounter and correct, and 
a lot less syntax for you to learn!
In our final example, the programmer attempts to add two numbers, but forgets to include 
the second one:
>>> 3 +
SyntaxError: invalid syntax
In later chapters, you will learn more about other kinds of program errors and how to 
repair the code that generates them.
Exercises
1. Suppose your script attempts to print the value of a variable that has not yet been 
assigned a value. How does the Python interpreter react?
2. Miranda has forgotten to complete an arithmetic expression before the end of a line 
of code. How will the Python interpreter react?
3. Why does Python code generate fewer types of syntax errors than code in other 
programming languages?
Suggestions for Further Reading
John Battelle, The Search: How Google and Its Rivals Rewrote the Rules of Business and Trans-
formed Our Culture  (New York: Portfolio Trade, 2006).
Tim Berners-Lee, Weaving the Web: The Original Design and Ultimate Destiny of the World 
Wide Web  (New York: HarperCollins, 2000).
Paul Graham, Hackers and Painters: Big Ideas from the Computer Age  (Sebastopol, CA: O’Reilly, 2004).
Katie Hafner and Matthew Lyon, Where Wizards Stay Up Late: The Origins of the Internet  (New 
York: Simon and Schuster, 1996).
Michael E. Hobart and Zachary S. Schiffman, Information Ages: Literacy, Numeracy, and the 
Computer Revolution  (Baltimore: The Johns Hopkins University Press, 1998).
Georges Ifrah, The Universal History of Computing: From the Abacus to the Quantum Computer  
(New York: John Wiley & Sons, Inc., 2001).
Walter Issacson, Steve Jobs  (New York: Simon & Schuster, 2011).
John Markoff, What the Doormouse Said: How the Sixties Counterculture Shaped the Personal 
Computer Industry  (New York: Viking, 2005).
Antonio García Martínez, Chaos Monkeys: Obscene Fortune and Random Failure in Silicon Val-
ley (New York: HarperCollins, 2016).
Cathy O’Neil, Weapons of Math Destruction: How Big Data Increases Inequality and Threatens 
Democracy  (New York: Crown, 2016).
Curtis White, We, Robots: Staying Human in the Age of Big Data  (Brooklyn, NY: Melville House, 2016).
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

31Summary
Summary
 vOne of the most fundamental ideas of computer science is the algorithm. An algorithm 
is a sequence of instructions for solving a problem. A computing agent can carry out 
these instructions to solve a problem in a finite amount of time.
 vAnother fundamental idea of computer science is information processing. Practically 
any relationship among real-world objects can be represented as information or data. 
Computing agents manipulate information and transform it by following the steps 
described in algorithms.
 vReal computing agents can be constructed out of hardware devices. These consist of 
a central processing unit (CPU), a memory, and input and output devices. The CPU 
contains circuitry that executes the instructions described by algorithms. The memory 
contains switches that represent binary digits. All information stored in memory is 
represented in binary form. Input devices such as a keyboard and flatbed scanner 
and output devices such as a monitor and speakers transmit information between the 
computer’s memory and the external world. These devices also transfer information 
between a binary form and a form that human beings can use.
 vSome real computers, such as those in wristwatches and cell phones, are specialized 
for a small set of tasks, whereas a desktop or laptop computer is a general-purpose 
 problem-solving machine.
 vSoftware provides the means whereby different algorithms can be run on a general-
purpose hardware device. The term software  can refer to editors and interpreters for 
developing programs; an operating system for managing hardware devices; user inter-
faces for communicating with human users; and applications such as word processors, 
spreadsheets, database managers, games, and media-processing programs.
 vSoftware is written in programming languages. Languages such as Python are high level; 
they resemble English and allow authors to express their algorithms clearly to other 
people. A program called an interpreter translates a Python program to a lower-level 
form that can be executed on a real computer.
 vThe Python shell provides a command prompt for evaluating and viewing the results of 
Python expressions and statements. IDLE is an integrated development environment that 
allows the programmer to save programs in files and load them into a shell for testing.
 vPython scripts are programs that are saved in files and run from a terminal command 
prompt. An interactive script consists of a set of input statements, statements that pro-
cess these inputs, and statements that output the results.
 vWhen a Python program is executed, it is translated into byte code. This byte code is 
then sent to the Python virtual machine (PVM) for further interpretation and execution.
 vSyntax is the set of rules for forming correct expressions and statements in a program-
ming language. When the interpreter encounters a syntax error in a Python program, it 
halts execution with an error message. Two examples of syntax errors are a reference to 
a variable that does not yet have a value and an indentation that is unexpected.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

32   Introduction
CHAPTER 1Review Questions
1. Which of the following are examples of algorithms?
a. A dictionary
b. A recipe
c. A set of instructions for putting together a utility shed
d. The spelling checker of a word processor
2. Which of the following contain information?
a. My grandmother’s china cabinet
b. An audio CD
c. A refrigerator
d. A book
e. A running computer
3. Which of the following are general-purpose computing devices?
a. A cell phone
b. A portable music player
c. A laptop computer
d. A programmable thermostat
4. Which of the following are input devices?
a. Speaker
b. Microphonec. Printer
d. A mouse
5. Which of the following are output devices?
a. A digital camera
b. A keyboardc. A flatbed scanner
d. A monitor
6. What is the purpose of the CPU?
a. Store information
b. Receive inputs from the human user
c. Decode and execute instructions
d. Send output to the human user
7. Which of the following translates and executes instructions in a programming 
language?
a. A compiler
b. A text editorc. A loader
d. An interpreter
8. Which of the following outputs data in a Python program?
a. The input statement
b. The assignment statementc. The print statement
d. The main function
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

33Projects
9. What is IDLE used to do?
a. Edit Python programs
b. Save Python programs to filesc. Run Python programs
d. All of the above
10. What is the set of rules for forming sentences in a language called?
a. Semantics
b. Pragmaticsc. Syntax
d. Logic
Projects
1. Open a Python shell, enter the following expressions, and observe the results:
a. 8
b. 8 * 2
c. 8 ** 2d. 8/12
e. 8 // 12
f.  8/0
2. Write a Python program that prints (displays) your name, address, and telephone number.
3. Evaluate the following code at a shell prompt: print ("Your name is", name) . 
Then assign name an appropriate value, and evaluate the statement again.
4. Open an IDLE window, and enter the program from Figure 1-7 that computes 
the area of a rectangle. Load the program into the shell by pressing the F5 key, 
and correct any errors that occur. Test the program with different inputs by 
 running it at least three times.
5. Modify the program of Project 4 to compute the area of a triangle. Issue the 
appropriate prompts for the triangle’s base and height, and change the names of 
the variables appropriately. Then, use the formula .5 * base * height  to com-
pute the area. Test the program from an IDLE window.
6. Write and test a program that computes the area of a circle. This program should 
request a number representing a radius as input from the user. It should use the formula 
3.14 * radius ** 2  to compute the area and then output this result suitably labeled.
7. Write and test a program that accepts the user’s name (as text) and age (as a number) 
as input. The program should output a sentence containing the user’s name and age.
8. Enter an input statement using the input function at the shell prompt. When the 
prompt asks you for input, enter a number. Then, attempt to add 1 to that num-
ber, observe the results, and explain what happened.
9. Enter an input statement using the input function at the shell prompt. When the 
prompt asks you for input, enter your first name, observe the results, and explain 
what happened.
10. Enter the expression help() at the shell prompt. Follow the instructions to 
browse the topics and modules.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

After completing this chapter, you will be able to
Describe the basic phases of software development: 
 analysis, design, coding, and testing
Use strings for the terminal input and output of text
Use integers and floating-point numbers in arithmetic 
operations
Construct arithmetic expressions
Initialize and use variables with appropriate names
Import functions from library modules
Call functions with arguments and use returned values 
appropriately
Construct a simple Python program that performs inputs, 
calculations, and outputs
Use docstrings to document Python programsCHAPTER 2
SOFTWARE 
 DEVELOPMENT, Data 
Types, and Expressions
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

35The Software Development Process
This chapter begins with a discussion of the software development process, followed by a 
case study in which we walk through the steps of program analysis, design, coding, and test -
ing. We also examine the basic elements from which programs are composed. These include 
the data types for text and numbers and the expressions that manipulate them. The chapter 
concludes with an introduction to the use of functions and modules in simple programs.
The Software Development Process
There is much more to programming than writing lines of code, just as there is more to 
building houses than pounding nails. The “more” consists of organization and planning, 
and various conventions for diagramming those plans. Computer scientists refer to the 
process of planning and organizing a program as software development . There are several 
approaches to software development. One version is known as the waterfall model .
The waterfall model consists of several phases:
1. Customer request —In this phase, the programmers receive a broad statement of 
a problem that is potentially amenable to a computerized solution. This step is also 
called the user requirements phase.
2. Analysis —The programmers determine what the program will do. This is some-
times viewed as a process of clarifying the specifications for the problem.
3. Design —The programmers determine how the program will do its task.
4. Implementation —The programmers write the program. This step is also called the 
coding phase.
5. Integration —Large programs have many parts. In the integration phase, these parts 
are brought together into a smoothly functioning whole, usually not an easy task.
6. Maintenance —Programs usually have a long life; a life span of 5 to 15 years is com-
mon for software. During this time, requirements change, errors are detected, and 
minor or major modifications are made.
The phases of the waterfall model are shown in Figure 2-1. As you can see, the figure resem -
bles a waterfall, in which the results of each phase flow down to the next. However, a mistake 
detected in one phase often requires the developer to back up and redo some of the work in 
the previous phase. Modifications made during maintenance also require backing up to ear -
lier phases. Taken together, these phases are also called the software development life cycle .
Although the diagram depicts distinct phases, this does not mean that developers must 
analyze and design a complete system before coding it. Modern software development 
is usually incremental  and iterative . This means that analysis and design may produce a 
rough draft, skeletal version, or prototype  of a system for coding, and then back up to ear-
lier phases to fill in more details after some testing. For purposes of introducing this pro-
cess, however, we treat these phases as distinct.
Programs rarely work as hoped the first time they are run; hence, they should be subjected 
to extensive and careful testing. Many people think that testing is an activity that applies 
only to the implementation and integration phases; however, you should scrutinize the 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

36   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2
outputs of each phase carefully. Keep in mind that mistakes found early are much less 
expensive to correct than those found late. Figure 2-2 illustrates some relative costs of 
repairing mistakes when found in different phases. These are not just financial costs but 
also costs in time and effort.
Figure 2-2  Relative costs of repairing mistakes that are found in different phasesSoftware Development PhaseCost of
Correcting
a FaultAnalysis Design Implementation Integration Maintenance
Figure 2-1  The waterfall model of the software development processImplementation
TestAnalysis
Verify
Integration
TestMaintenanceDesign
VerifyCustomer request
Verify
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

37The Software Development Process
Keep in mind that the cost of developing software is not spread equally over the phases. 
The percentages shown in Figure 2-3 are typical.
You might think that implementation takes the most time and therefore costs the most. 
However, as you can see in Figure 2-3, maintenance is the most expensive part of software 
development. The cost of maintenance can be reduced by careful analysis, design, and 
implementation.
As you read this book and begin to sharpen your programming skills, you should  remember 
two points:
1. There is more to software development than writing code.
2. If you want to reduce the overall cost of software development, write programs 
that are easy to maintain. This requires thorough analysis, careful design, and  
a good coding style. We will have more to say about coding styles throughout  
the book.Figure 2-3  Percentage of total cost incurred  
in each phase of the development processIntegration 8%Implementation 8%Maintenance 68%Design 8%
Analysis 8%
Exercises
1. List four phases of the software development process, and explain what they 
accomplish.
2. Jack says that he will not bother with analysis and design but proceed directly to 
coding his programs. Why is that not a good idea?
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

38   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2CASE STU DY: Income Tax Calculator
Most of the chapters in this book include a case study that illustrates the software 
development process. This approach may seem overly elaborate for small programs, 
but it scales up well when programs become larger. The first case study develops a 
program that calculates income tax.
Each year, nearly everyone with an income faces the unpleasant task of computing 
his or her income tax return. If only it could be done as easily as suggested in this 
case study! We start with the customer request phase.
Request
The customer requests a program that computes a person’s income tax.
Analysis
Analysis often requires the programmer to learn some things about the problem 
domain, in this case, the relevant tax law. For the sake of simplicity, let’s assume the 
following tax laws:
 vAll taxpayers are charged a flat tax rate of 20%.
 vAll taxpayers are allowed a $10,000 standard deduction.
 vFor each dependent, a taxpayer is allowed an additional $3,000 deduction.
 vGross income must be entered to the nearest penny.
 vThe income tax is expressed as a decimal number.
Another part of analysis determines what information the user will have to provide. 
In this case, the user inputs are gross income and number of dependents. The 
program calculates the income tax based on the inputs and the tax law and then 
displays the income tax.  Figure 2-4 shows the proposed terminal-based interface. 
Characters in italics indicate user inputs. The program prints the rest. The inclusion 
of an interface at this point is a good idea because it allows the customer and the 
programmer to discuss the intended program’s behavior in a context understand -
able to both.
Enter the gross income:  150000.00
Enter the number of dependents:  3
The income tax is $26200.0
Figure 2-4  The user interface for the income tax calculator
(continues )
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

39The Software Development Process
Design
During analysis, we specify what a program is going to do. In the next phase, design, 
we describe how the program is going to do it. This usually involves writing an algo-
rithm. In Chapter 1, we showed how to write algorithms in  ordinary English. In fact, 
algorithms are more often written in a somewhat stylized  version of English called 
pseudocode . Here is the pseudocode for our income tax program:
Input the gross income and number of dependents
Compute the taxable income using the formula
Taxable income = gross income - 10000 - (3000 * number of dependents)
Compute the income tax using the formula
Tax = taxable income * 0.20
Print the tax
Although there are no precise rules governing the syntax of pseudocode, in your 
pseudocode you should strive to describe the essential elements of the program in a 
clear and concise manner. Note that this pseudocode closely resembles Python code, 
so the transition to the coding step should be straightforward.
Implementation (Coding)
Given the preceding pseudocode, an experienced programmer would now find it easy 
to write the corresponding Python program. For a beginner, on the other hand, writing 
the code can be the most difficult part of the process. Although the program that fol-
lows is simple by most standards, do not expect to understand every bit of it at first. 
The rest of this chapter explains the elements that make it work, and much more.
"""
Program: taxform.py
Author: Ken Lambert
Compute a person’s income tax.
1. Significant constants
        tax rate
        standard deduction
        deduction per dependent
2. The inputs are
        gross income
        number of dependents
3. Computations:
        taxable income = gross income - the standard  
               deduction - a   deduction for each dependent
        income tax = is a fixed percentage of the taxable income
4. The outputs are
        the income tax
"""(continued  )
(continues )
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

40   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2# Initialize the constants
TAX_RATE = 0.20
STANDARD_DEDUCTION = 10000.0
DEPENDENT_DEDUCTION = 3000.0
 
# Request the inputs
grossIncome  = float(input("Enter the gross income: " ))
numDependents  = int(input("Enter the number of dependents: " ))
 
# Compute the income tax
taxableIncome = grossIncome - STANDARD_DEDUCTION - \  
            DEPENDENT_DEDUCTION * numDependents
incomeTax = taxableIncome * TAX_RATE
 
# Display the income tax
print("The income tax is $"  + str(incomeTax))
Testing
Our income tax program can run as a script from an IDLE window. If there are no syntax 
errors, we will be able to enter a set of inputs and view the results. However, a single 
run without syntax errors and with correct outputs provides just a slight indication of a 
program’s correctness. Only thorough testing can build confidence that a program is 
working correctly. Testing is a deliberate process that requires some planning and disci -
pline on the programmer’s part. It would be much easier to turn the program in after the 
first successful run to meet a deadline or to move on to the next assignment. But your 
grade, your job, or people’s lives might be affected by the slipshod testing of software.
Testing can be performed easily from an IDLE window. The programmer just loads the 
program repeatedly into the shell and enters different sets of inputs. The real chal-
lenge is coming up with sets of inputs that can reveal an error. An error at this point, 
also called a logic error  or a design error , is an unexpected output.
A correct program  produces the expected output for any legitimate input. The tax 
calculator’s analysis does not provide a specification of what inputs are legitimate, but 
common sense indicates that they would be numbers greater than or equal to 0. Some 
of these inputs will produce outputs that are less than 0, but we will assume for now that 
these outputs are expected. Even though the range of the input numbers on a computer 
is finite, testing all of the possible combinations of inputs would be impractical. The chal -
lenge is to find a smaller set of inputs, called a test suite , from which we can conclude 
that the program will likely be correct for all inputs. In the tax program, we try inputs of 
0, 1, and 2 for the number of dependents. If the program works correctly with these, 
we can assume that it will work correctly with larger values. The test inputs for the gross 
income are a number equal to the standard deduction and a number twice that amount 
(10000 and 20000, respectively). These two values will show the cases of a minimum (continued  )
(continues )
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

41Strings, Assignment, and Comments
Strings, Assignment, and Comments
Text processing is by far the most common application of computing. E-mail, text messag-
ing, Web pages, and word processing all rely on and manipulate data consisting of strings 
of characters. This section introduces the use of strings for the output of text and the docu-
mentation of Python programs. We begin with an introduction to data types in general.
Data Types
In the real world, we use data all the time without bothering to consider what kind of data 
we’re using. For example, consider this sentence: “In 2007, Micaela paid $120,000 for her house 
at 24 East Maple Street. ” This sentence includes at least four pieces of data—a name, a date, 
a price, and an address—but of course you don’t have to stop to think about that before you 
utter the sentence. You certainly don’t have to stop to consider that the name consists only of 
text characters, the date and house price are numbers, and so on. However, when we use data 
in a computer program, we do need to keep in mind the type of data we’re using. We also need 
to keep in mind what we can do with (what operations can be performed on) particular data.
In programming, a data type  consists of a set of values and a set of operations that can be 
performed on those values. A literal  is the way a value of a data type looks to a program-
mer. The programmer can use a literal in a program to mention a data value. When the (continued  )
expected tax (0) and expected taxes that are less than or greater than 0. The program 
is run with each possible combination of the two inputs. Table 2-1 shows the possible 
combinations of inputs and the expected outputs in the test suite.
If there is a logic error in the code, it will almost certainly be caught using these data. 
Note that the negative outputs are not considered errors. We will see how to prevent 
such computations in the next chapter.Number of Dependents Gross Income Expected Tax
0 10000 0
1 10000 –600
2 10000 –1200
0 20000 2000
1 20000 1400
2 20000 800
Table 2-1  The test suite for the tax calculator program
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

42   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2Python interpreter evaluates a literal, the value it returns is simply that literal. Table 2-2 
shows example literals of several Python data types.
Type of Data Python Type Name Example Literals
Integers int –1, 0, 1, 2
Real numbers float –0.55, .3333, 3.14, 6.0
Character strings str "Hi", "", 'A', "66"
Table 2-2  Literals for some Python data types
The first two data types listed in Table 2-2, int and float, are called numeric data types , 
because they represent numbers. You’ll learn more about numeric data types later in this chap -
ter. For now, we will focus on character strings—which are often referred to simply as strings.
String Literals
In Python, a string literal is a sequence of characters enclosed in single or double quotation 
marks. The following session with the Python shell shows some example strings:
>>> 'Hello there!'
'Hello there!'
>>> "Hello there!"
'Hello there!'
>>> ''
''
>>> ""
''
 
The last two string literals ( '' and "") represent the empty string . Although it contains no 
characters, the empty string is a string nonetheless. Note that the empty string is different 
from a string that contains a single blank space character, " ".
Double-quoted strings are handy for composing strings that contain single quotation marks 
or apostrophes. Here is a self-justifying example:
>>> "I'm using a single quote in this string!"
"I'm using a single quote in this string!"
>>> print("I'm using a single quote in this string!" )
I'm using a single quote in this string!
Note that the print function displays the nested quotation mark but not the enclosing 
 quotation marks. A double quotation mark can also be included in a string literal if one 
uses the single quotation marks to enclose the literal.
When you write a string literal in Python code that will be displayed on the screen as output, 
you need to determine whether you want to output the string as a single line or as a multi-
line paragraph. If you want to output the string as a single line, you have to include the entire 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

43Strings, Assignment, and Comments
string literal (including its opening and closing quotation marks) in the same line of code. 
Otherwise, a syntax error will occur. To output a paragraph of text that contains several lines, 
you could use a separate print function call for each line. However, it is more convenient to 
enclose the entire string literal, line breaks and all, within three consecutive quotation marks 
(either single or double) for printing. The next session shows how this is done:
>>> print("""This very long sentence extends
all the way to the next line.""" )
This very long sentence extends 
all the way to the next line.
Note that the first line in the output ends exactly where the first line ends in the code.
When you evaluate a string in the Python shell without the print function, you can see the 
literal for the newline character , \n, embedded in the result, as follows:
>>> """This very long sentence extends
all the way to the next line."""
'This very long sentence extends\nall the way to the next line.'
Escape Sequences
The newline character \n is called an escape sequence . Escape sequences are the way 
Python expresses special characters, such as the tab, the newline, and the backspace (delete 
key), as literals. Table 2-3 lists some escape sequences in Python.
Escape Sequence Meaning
\b Backspace
\n Newline
\t Horizontal tab
\\ The \ character
\' Single quotation mark
\" Double quotation mark
Table 2-3  Some escape sequences in Python
Because the backslash is used for escape sequences, it must be escaped to appear as a literal 
character in a string. Thus, print('\\')  would display a single \ character.
String Concatenation
You can join two or more strings to form a new string using the concatenation operator +. 
Here is an example:
>>> "Hi " + "there, "  + "Ken!"
'Hi there. Ken!'
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

44   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2The * operator allows you to build a string by repeating another string a given number of 
times. The left operand is a string, and the right operand is an integer. For example, if you 
want the string "Python" to be preceded by 10 spaces, it would be easier to use the * opera-
tor with 10 and one space than to enter the 10 spaces by hand. The next session shows the 
use of the * and + operators to achieve this result:
>>> " " * 10 + "Python"
'          Python'
Variables and the Assignment Statement
As we saw in Chapter 1, a variable  associates a name with a value, making it easy to 
remember and use the value later in a program. You need to be mindful of a few rules when 
choosing names for your variables. For example, some names, such as if, def, and import, 
are reserved for other purposes and thus cannot be used for variable names. In general, 
a variable name must begin with either a letter or an underscore ( _), and can contain any 
number of letters, digits, or other underscores. Python variable names are case sensitive; 
thus, the variable WEIGHT is a different name from the variable weight. Python programmers 
typically use lowercase letters for variable names, but in the case of variable names that con -
sist of more than one word, it’s common to begin each word in the variable name (except 
for the first one) with an uppercase letter. This makes the variable name easier to read. For 
example, the name interestRate  is slightly easier to read than the name interestrate .
Programmers use all uppercase letters for the names of variables that contain values that 
the program never changes. Such variables are known as symbolic constants . Examples of 
symbolic constants in the tax calculator case study are TAX_RATE and STANDARD_DEDUCTION .
Variables receive their initial values and can be reset to new values with an assignment 
statement . The simplest form of an assignment statement is the following:
<variable name> = <expression>
As mentioned in Chapter 1, the terms enclosed in angle brackets name or describe a part 
of a Python code construct. Thus, the notation <variable name>  stands for any Python 
variable name, such as totalIncome  or taxRate. The notation <expression>  stands for any 
Python expression, such as " " * 10 + "Python".
The Python interpreter first evaluates the expression on the right side of the assignment 
symbol and then binds the variable name on the left side to this value. When this happens 
to the variable name for the first time, it is called defining  or initializing  the variable. Note 
that the = symbol means assignment, not equality. After you initialize a variable, subsequent 
uses of the variable name in expressions are known as variable references .
When the interpreter encounters a variable reference in any expression, it looks up the 
associated value. If a name is not yet bound to a value when it is referenced, Python signals 
an error. The next session shows some definitions of variables and their references:
>>> firstName =  "Ken"
>>> secondName  = "Lambert"
>>> fullName  = firstName  + " " + secondName
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

45Strings, Assignment, and Comments
>>> fullName
'Ken Lambert'
The first two statements initialize the variables firstName and secondName  to string val-
ues. The next statement references these variables, concatenates the values referenced by 
the variables to build a new string, and assigns the result to the variable fullName (“con-
catenate” means “glue together”). The last line of code is a simple reference to the variable 
fullName, which returns its value.
Variables serve two important purposes in a program. They help the programmer keep 
track of data that change over time. They also allow the programmer to refer to a complex 
piece of information with a simple name. Any time you can substitute a simple thing for a 
more complex one in a program, you make the program easier for programmers to under-
stand and maintain. Such a process of simplification is called abstraction , and it is one of 
the fundamental ideas of computer science. Throughout this book, you’ll learn about other 
abstractions used in computing, including functions, modules, and classes.
The wise programmer selects names that inform the human reader about the purpose of 
the data. This, in turn, makes the program easier to maintain and troubleshoot. A good 
program not only performs its task correctly but it also reads like an essay in which each 
word is carefully chosen to convey the appropriate meaning to the reader. For example, a 
program that creates a payment schedule for a simple interest loan might use the variables 
rate, initialAmount , currentBalance , and interest.
Program Comments and Docstrings
We conclude this subsection on strings with a discussion of program comments . A com -
ment is a piece of program text that the computer ignores but that provides useful docu -
mentation to programmers. At the very least, the author of a program can include his or her 
name and a brief statement about the program’s purpose at the beginning of the program 
file. This type of comment, called a docstring , is a multi-line string of the form discussed 
earlier in this section. Here is a docstring that begins a typical program for a lab session:
"""
Program: circle.py
Author: Ken Lambert
Last date modified: 10/10/17
 
The purpose of this program is to compute the area of a  
circle. The input is an integer or floating-point number  
representing the radius of the circle. The output is a  
floating-point number labeled as the area of the circle.
"""
In addition to docstrings, end-of-line comments  can document a program. These com-
ments begin with the # symbol and extend to the end of a line. An end-of-line comment 
might explain the purpose of a variable or the strategy used by a piece of code, if it is not 
already obvious. Here is an example:
>>> RATE  = 0.85 # Conversion rate for Canadian to US dollars
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

46   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2Throughout this book, docstrings appear in green and end-of-line comments appear in red.
In a program, good documentation can be as important as executable code. Ideally, pro-
gram code is self-documenting, so a human reader can instantly understand it. However, a 
program is often read by people who are not its authors, and even the authors might find 
their own code inscrutable after months of not seeing it. The trick is to avoid documenting 
code that has an obvious meaning, but to aid the poor reader when the code alone might 
not provide sufficient understanding. With this end in mind, it’s a good idea to do the 
following:
1. Begin a program with a statement of its purpose and other information that would 
help orient a programmer called on to modify the program at some future date.
2. Accompany a variable definition with a comment that explains the variable’s purpose.
3. Precede major segments of code with brief comments that explain their purpose. 
The case study program presented earlier in this chapter does this.
4. Include comments to explain the workings of complex or tricky sections of code.
Exercises
1. Let the variable x be "dog" and the variable y be "cat". Write the values returned 
by the following operations:
a. x + y
b. "the " + x + " chases the " + y
c. x * 4
2. Write a string that contains your name and address on separate lines using embed-
ded newline characters. Then write the same string literal without the newline 
characters.
3. How does one include an apostrophe as a character within a string literal?
4. What happens when the print function prints a string literal with embedded 
 newline characters?
5. Which of the following are valid variable names?
a. length
b. _width
c. firstBase
d. 2MoreToGo
e. halt!
6. List two of the purposes of program documentation.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

47Numeric Data Types and Character Sets
Numeric Data Types and Character Sets
The first applications of computers were created to crunch numbers. Although text and 
media processing have lately been of increasing importance, the use of numbers in many 
applications is still very important. In this section, we give a brief overview of numeric data 
types and their cousins, character sets .
Integers
As you learned in mathematics, the integers  include 0, the positive whole numbers, and the 
negative whole numbers. Integer literals in a Python program are written without commas, 
and a leading negative sign indicates a negative value.
Although the range of integers is infinite, a real computer’s memory places a limit on the 
magnitude of the largest positive and negative integers. The most common implementa-
tion of the int data type in many programming languages consists of the integers from 222,147,483,648(2 )31 to 2 2,147,483,647(2 1)31. However, the magnitude of a Python 
integer is much larger and is limited only by the memory of your computer. As an experi-
ment, try evaluating the expression 2147483647 ** 100 , which raises the largest positive 
int value to the 100th power. You will see a number that contains many lines of digits!
Floating-Point Numbers
A real number in mathematics, such as the value of p (3.1416...), consists of a whole num-
ber, a decimal point, and a fractional part. Real numbers have infinite precision , which 
means that the digits in the fractional part can continue forever. Like the integers, real 
numbers also have an infinite range. However, because a computer’s memory is not infi-
nitely large, a computer’s memory limits not only the range but also the precision that can 
be represented for real numbers. Python uses floating-point  numbers to represent real 
numbers. Values of the most common implementation of Python’s float type range from 
approximately 210308 to 10308 and have 16 digits of precision.
A floating-point number can be written using either ordinary decimal notation  or 
 scientific notation . Scientific notation is often useful for mentioning very large numbers. 
Table 2-4 shows some equivalent values in both notations.
Decimal Notation Scientific Notation Meaning
3.78 3.78e03.78 100337.8 3.78e13.78 10133780.0 3.78e33.78 10330.378 3.78e–13.78 10132
0.00378 3.78e–33.78 10332
Table 2-4  Decimal and scientific notations for floating-point numbers
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

48   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2Character Sets
Some programming languages use different data types for strings and individual characters. In 
Python, character literals look just like string literals and are of the string type. T o mark the differ -
ence in this book, we use single quotes to enclose single-character strings, and double quotes to 
enclose multi-character strings. Thus, we refer to 'H' as a character and "Hi!" as a string, even 
though they are both technically Python strings, and both are color-coded in green in this text.
As you learned in Chapter 1, all data and instructions in a program are translated to binary 
numbers before being run on a real computer. To support this translation, the characters in a 
string each map to an integer value. This mapping is defined in character sets, among them 
the ASCII set  and the Unicode set . (The term ASCII stands for American Standard Code for 
Information Interchange.) In the 1960s, the original ASCII set encoded each keyboard char -
acter and several control characters using the integers from 0 through 127. An example of a 
control character is Control 1D, which is the command to terminate a shell window. As new 
function keys and some international characters were added to keyboards, the ASCII set dou -
bled in size to 256 distinct values in the mid-1980s. Then, when characters and symbols were 
added from languages other than English, the Unicode set was created to support 65,536 val -
ues in the early 1990s. Unicode supports more than 128,000 values at the present time.
Table 2-5 shows the mapping of character values to the first 128 ASCII codes. The digits in 
the left column represent the leftmost digits of an ASCII code, and the digits in the top row 
are the rightmost digits. Thus, the ASCII code of the character 'R' at row 8, column 2 is 82.
0123456789
0 NUL SOH STX ETX EOT ENQ ACK BEL BS HT
1 LF VT FF CR SO SI DLE DCI DC2 DC3
2 DC4 NAK SYN ETB CAN EM SUB ESC FS GS
3 RS US SP ! “ # $ % & `
4 ()* 1 ,-./ 0 1
5 23456789: ;
6 < 5 >? @ABCDE
7 FG HI JKLM N O
8 PQRSTUVW XY
9 Z[ \ ] ^_` abc
10 def ghI j kl m
11 noPqrSt uvw
12 X y z { | } ~ DEL
Table 2-5  The original ASCII character set
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

49Expressions
Some might think it odd to include characters in a discussion of numeric types. However, 
as you can see, the ASCII character set maps to a set of integers. Python’s ord and chr func-
tions convert characters to their numeric ASCII codes and back again, respectively. The 
next session uses the following functions to explore the ASCII system:
>>> ord('a')
97
>>> ord('A')
65
>>> chr(65)
'A'
>>> chr(66)
'B'
Note that the ASCII code for 'B' is the next number in the sequence after the code for 'A'. 
These two functions provide a handy way to shift letters by a fixed amount. For example, if 
you want to shift three places to the right of the letter 'A', you can write chr(ord('A') + 3).
Exercises
1. Which data type would most appropriately be used to represent the following data 
values?
a. The number of months in a year
b. The area of a circle
c. The current minimum wage
d. The approximate age of the universe (12,000,000,000 years)
e. Your name
2. Explain the differences between the data types int and float.
3. Write the values of the following floating-point numbers in Python’s scientific notation:
a. 355.76
b. 0.007832
c. 4.3212
4. Consult Table 2-5 to write the ASCII values of the characters '$' and '&'.
Expressions
As we have seen, a literal evaluates to itself, whereas a variable reference evaluates to the 
variable’s current value. Expressions  provide an easy way to perform operations on data 
values to produce other data values. You saw strings used in expressions earlier. When 
entered at the Python shell prompt, an expression’s operands are evaluated, and its operator 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

50   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2is then applied to these values to compute the value of the expression. In this section,  
we examine arithmetic expressions in more detail.
Arithmetic Expressions
An arithmetic expression  consists of operands and operators combined in a manner that is 
already familiar to you from learning algebra. Table 2-6 shows several arithmetic operators 
and gives examples of how you might use them in Python code.
Operator Meaning Syntax
– Negation –a
** Exponentiation a ** b
* Multiplication a * b
/ Division a / b
// Quotient a // b
% Remainder or modulus a % b
+ Addition a + b
– Subtraction a – b
Table 2-6  Arithmetic operators
In algebra, you are probably used to indicating multiplication like this: ab. However, in 
Python, we must indicate multiplication explicitly, using the multiplication operator ( *), 
like this: a * b. Binary operators are placed between their operands ( a * b, for example), 
whereas unary operators are placed before their operands ( –a, for example).
The precedence rules  you learned in algebra apply during the evaluation of arithmetic 
expressions in Python:
 vExponentiation has the highest precedence and is evaluated first.
 vUnary negation is evaluated next, before multiplication, division, and remainder.
 vMultiplication, both types of division, and remainder are evaluated before addition and 
subtraction.
 vAddition and subtraction are evaluated before assignment.
 vWith two exceptions, operations of equal precedence are left associative, so they are 
evaluated from left to right. Exponentiation and assignment operations are right asso-
ciative, so consecutive instances of these are evaluated from right to left.
 vYou can use parentheses to change the order of evaluation.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

51Expressions
Table 2-7 shows some arithmetic expressions and their values.
Expression Evaluation Value
5 + 3 * 2 5 + 6 11
(5 + 3) * 2 8 * 2 16
6 % 2 0 0
2 * 3 ** 2 2 * 9 18
–3 ** 2 –(3 ** 2) –9
(3) ** 2 9 9
2 ** 3 ** 2 2 ** 9 512
(2 ** 3) ** 2 8 ** 2 64
45 / 0 Error: cannot divide by 0
45 % 0 Error: cannot divide by 0
Table 2-7  Some arithmetic expressions and their values
The last two lines of Table 2-7 show attempts to divide by 0, which result in an error. These 
expressions are good illustrations of the difference between syntax and semantics . Syn -
tax is the set of rules for constructing well-formed expressions or sentences in a language. 
Semantics is the set of rules that allow an agent to interpret the meaning of those expres-
sions or sentences. A computer generates a syntax error when an expression or sentence is 
not well formed. A semantic error  is detected when the action that an expression describes 
cannot be carried out, even though that expression is syntactically correct. Although the 
expressions 45 / 0 and 45 % 0 are syntactically correct, they are meaningless, because a 
computing agent cannot carry them out. Human beings can tolerate all kinds of syntax 
errors and semantic errors when they converse in natural languages. By contrast, comput-
ing agents can tolerate none of these errors.
With the exception of exact division, when both operands of an arithmetic expression are 
of the same numeric type ( int or float), the resulting value is also of that type. When each 
operand is of a different type, the resulting value is of the more general type. Note that the 
float type is more general than the int type. The quotient operator // produces an integer 
quotient, whereas the exact division operator / always produces a float. Thus, 3 // 4 pro-
duces 0, whereas 3 / 4 produces .75.
Although spacing within an expression is not important to the Python interpreter, pro -
grammers usually insert a single space before and after each operator to make the code 
easier for people to read. Normally, an expression must be completed on a single line of 
Python code. When an expression becomes long or complex, you can move to a new line 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

52   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2by placing a backslash character \ at the end of the current line. The next example shows 
this technique:
>>> 3 + 4 * \
2 ** 5
131
Make sure to insert the backslash before or after an operator. If you break lines in this man-
ner in IDLE, the editor automatically indents the code properly.
As you will see shortly, you can also break a long line of code immediately after a comma. 
Examples include function calls with several arguments.
Mixed-Mode Arithmetic and Type Conversions
You have seen how the // operator produces an integer result and the / operator pro-
duces a floating-point result with two integers. What happens when one operand is an 
int and the other is a float? When working with a handheld calculator, you do not give 
much thought to the fact that you intermix integers and floating-point numbers. Perform-
ing calculations involving both integers and floating-point numbers is called mixed-mode 
 arithmetic . For instance, if a circle has radius 3, you compute the area as follows:
>>> 3.14 * 3 ** 2
28.26
How does Python perform this type of calculation? In a binary operation on operands of 
different numeric types, the less general type (int) is temporarily and automatically con-
verted to the more general type (float) before the operation is performed. Thus, in the 
example expression, the value 9 is converted to 9.0 before the multiplication.
You must use a type conversion function  when working with the input of numbers. A type 
conversion function is a function with the same name as the data type to which it converts. 
Because the input function returns a string as its value, you must use the function int or float 
to convert the string to a number before performing arithmetic, as in the following example:
>>> radius  = input("Enter the radius: " )
Enter the radius:  3.2
>>> radius
'3.2'
>>> float(radius)
3.2
>>> float(radius) ** 2 * 3.14
32.153600000000004
Table 2-8 lists some common type conversion functions and their uses.
Note that the int function converts a float to an int by truncation, not by rounding to the 
nearest whole number. Truncation simply chops off the number’s fractional part. The round 
function rounds a float to the nearest int as in the next example:
>>> int(6.75)
6
>>> round(6.75)
7
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

53Expressions
Another use of type conversion occurs in the construction of strings from numbers and 
other strings. For instance, assume that the variable profit refers to a floating-point number 
that represents an amount of money in dollars and cents. Suppose that, to build a string that 
represents this value for output, we need to concatenate the $ symbol to the value of profit. 
However, Python does not allow the use of the + operator with a string and a number:
>>> profit  = 1000.55
>>> print('$' + profit)
 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: cannot concatenate 'str' and 'float' objects
To solve this problem, we use the str function to convert the value of profit to a string 
and then concatenate this string to the $ symbol, as follows:
>>> print('$' + str(profit))
$1000.55
Python is a strongly typed programming language . The interpreter checks data types of 
all operands before operators are applied to those operands. If the type of an operand is not 
appropriate, the interpreter halts execution with an error message. This error checking pre-
vents a program from attempting to do something that it cannot do.Conversion Function Example Use Value Returned
int(<a number or a string>) int(3.77) 3
int("33") 33
float(<a number or a string>) float(22) 22.0
str(<any value>) str(99) '99'
Table 2-8  Type conversion functions
Exercises
1. xy55 Let 8and 2. Write the values of the following expressions:
a. x + y * 3
b. (x + y) * 3
c. x ** y
d. x % y
e. x / 12.0
f. x // 6
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

54   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2
Using Functions and Modules
Thus far in this chapter, we have examined two ways to manipulate data within expres -
sions. We can apply an operator such as + to one or more operands to produce a new data 
value. Alternatively, we can call a function such as round with one or more data values to 
produce a new data value. Python includes many useful functions, which are organized 
in libraries of code called modules . In this section, we examine the use of functions and 
modules.
Calling Functions: Arguments and Return Values
A function  is a chunk of code that can be called by name to perform a task. Functions often 
require arguments , that is, specific data values, to perform their tasks. Names that refer to 
arguments are also known as parameters . When a function completes its task (which is 
usually some kind of computation), the function may send a result back to the part of the 
program that called that function in the first place. The process of sending a result back to 
another part of a program is known as returning a value .
For example, the argument in the function call round(6.5)  is the value 6.5, and the value 
returned is 7. When an argument is an expression, it is first evaluated, and then its value is 
passed to the function for further processing. For instance, the function call abs(4 – 5)   
first evaluates the expression 4 – 5 and then passes the result, –1, to abs. Finally, abs 
returns 1.
The values returned by function calls can be used in expressions and statements. For exam-
ple, the function call print(abs(4 – 5) + 3)  prints the value 4.
Some functions have only optional arguments , some have required arguments , and some 
have both required and optional arguments. For example, the round function has one 
required argument, the number to be rounded. When called with just one argument, the 
round function exhibits its default behavior , which is to return the nearest whole  number 
with a fractional part of 0. However, when a second, optional argument is supplied, this 
argument, a number, indicates the number of places of precision to which the first  argument 
should be rounded. For example, round(7.563, 2)  returns 7.56.2. x5 Let 4.66 Write the values of the following expressions:
a. round(x)
b. int(x)
3. How does a Python programmer round a float value to the nearest int value?
4. How does a Python programmer concatenate a numeric value to a string value?
5. Assume that the variable x has the value 55. Use an assignment statement to incre-
ment the value of x by 1.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

55Using Functions and Modules
To learn how to use a function’s arguments, consult the documentation on functions 
in the shell. For example, Python’s help function displays information about round, as 
follows:
>>> help(round)
Help on built-in function round in module builtin:
 
round(...)
    round(number[, ndigits]) -> floating point number
 
    Round a number to a given precision in decimal digits  (default 0 digits).  
    This returns an int when called  with one argument, otherwise the same type as  
    number,  ndigits may be negative.
Each argument passed to a function has a specific data type. When writing code that 
involves functions and their arguments, you need to keep these data types in mind. A pro-
gram that attempts to pass an argument of the wrong data type to a function will usually 
generate an error. For example, one cannot take the square root of a string, but only of a 
number. Likewise, if a function call is placed in an expression that expects a different type 
of operand than that returned by the function, an error will be raised. If you’re not sure of 
the data type associated with a particular function’s arguments, read the documentation.
The math Module
Functions and other resources are coded in components called modules . Functions like 
abs and round from the __builtin__  module are always available for use, whereas the 
programmer must explicitly import other functions from the modules where they are 
defined.
The math module includes several functions that perform basic mathematical operations. 
The next code session imports the math module and lists a directory of its resources:
>>> import math
>>> dir(math)
['__doc__', '__file__', '__loader__', '__name__',  
'__package__', '__spec__', 'acos', 'acosh', 'asin',  
'asinh',  'atan', 'atan2', 'atanh', 'ceil', 'copysign',  
'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp',  
'expm1', 'fabs',  'factorial', 'floor', 'fmod', 'frexp',  
'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose',  
'isfinite', 'isinf', 'isnan',  'ldexp', 'lgamma', 'log',  
'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow',  
'radians', 'sin', 'sinh', 'sqrt',  'tan', 'tanh', 'tau',  
'trunc']
This list of function names includes some familiar trigonometric functions as well as 
Python’s most exact estimates of the constants p and e.
To use a resource from a module, you write the name of a module as a qualifier, followed 
by a dot ( .) and the name of the resource. For example, to use the value of pi from the math 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

56   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2module, you would write the following code: math.pi. The next session uses this technique 
to display the value of p and the square root of 2:
>>> math.pi
3.1415926535897931
>>> math.sqrt(2)
1.4142135623730951
Once again, help is available if needed:
>>> help(math.cos)
Help on built-in function cos in module math:
cos(...)
    cos(x)
 
    Return the cosine of x (measured in radians).
Alternatively, you can browse through the documentation for the entire module by entering 
help(math) . The function help uses a module’s own docstring and the docstrings of all its 
functions to print the documentation.
If you are going to use only a couple of a module’s resources frequently, you can avoid 
the use of the qualifier with each reference by importing the individual resources, as 
follows:
>>> from math import pi, sqrt
>>> print(pi, sqrt(2))
3.14159265359 1.41421356237
Programmers occasionally import all of a module’s resources to use without the qualifier. 
For example, the statement from math import *  would import all of the math module’s 
resources.
Generally, the first technique of importing resources (that is, importing just the module’s 
name) is preferred. The use of a module qualifier not only reminds the reader of a function’s 
purpose but also helps the computer to discriminate between different functions that have 
the same name.
The Main Module
In the case study, earlier in this chapter, we showed how to write documentation for a 
Python script. To differentiate this script from the other modules in a program (and there 
could be many), we call it the main module . Like any module, the main module can also 
be imported. Instead of launching the script from a terminal prompt or loading it into the 
shell from IDLE, you can start IDLE from the terminal prompt and import the script as a 
 module. Let’s do that with the taxform.py  script, as follows:
>>> import taxform
Enter the gross income:  120000
Enter the number of dependents:  2
The income tax is $20800.0
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

57Using Functions and Modules
After importing a main module, you can view its documentation by running the help function:
>>> help(taxform)
DESCRIPTION
Program: taxform.py
Author: Ken
Compute a person’s income tax.
Significant constants
   tax rate
   standard deduction
   deduction per dependent 
The inputs are
   gross income
   number of dependents
Computations:
   net income 5 gross income - the standard deduction - a 
deduction for each dependent
   income tax 5 is a fixed percentage of the net income
The outputs are
   the income tax
Program Format and Structure
This is a good time to step back and get a sense of the overall format and structure of 
 simple Python programs. It’s a good idea to structure your programs as follows:
 vStart with an introductory comment stating the author’s name, the purpose of the program, 
and other relevant information. This information should be in the form of a docstring.
 vThen, include statements that do the following:
 vImport any modules needed by the program.
 vInitialize important variables, suitably commented.
 vPrompt the user for input data and save the input data in variables.
 vProcess the inputs to produce the results.
 vDisplay the results.
T ake a moment to review the income tax program presented in the case study at the beginning 
of this chapter. Notice how the program conforms to this basic organization. Also, notice that the 
various sections of the program are separated by whitespace (blank lines). Remember, programs 
should be easy for other programmers to read and understand. They should read like essays!
Running a Script from a Terminal Command Prompt
Thus far in this book, we have been developing and running Python programs experimen-
tally in IDLE. When a program’s development and testing are finished, the program can 
be released to others to run on their computers. Python must be installed on a user’s com-
puter, but the user need not run IDLE to run a Python script.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

58   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2One way to run a Python script is to open a terminal command prompt window. On a 
computer running Windows 10, click in the “ Type here to search ” box on the Taskbar, 
type Command Prompt , and click Command Prompt  in the list. In earlier versions of 
Windows, select the Start  button, select All Programs , select Accessories , and then select 
Command Prompt . On a Macintosh or UNIX-based system, this is a terminal window. A 
terminal window on a Macintosh is shown in Figure 2-5.
Figure 2-5  A terminal window on a Macintosh
After the user has opened a terminal window, she must navigate or change directories until 
the prompt shows that she is attached to the directory that contains the Python script. For 
example, if we assume that the script named taxform.py  is in the pythonfiles  directory 
under the terminal’s current directory, Figure 2-6 shows the commands to change to this 
directory and list its contents.
Figure 2-6  Changing to another directory and listing its contents
When the user is attached to the appropriate directory, she can run the script by enter -
ing the command python3 scriptname.py  at the command prompt (be careful: if you 
run python  instead of python3 , you might launch the interpreter for Python 2, which 
will not run all of the programs in this book). Figure 2-7 shows this step and a run of the 
 taxform  script.
All Python installations also provide the capability of launching Python scripts by double-
clicking the files from the operating system’s file browser. On Windows systems, this feature 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

59Summary
is automatic, whereas on Macintosh and UNIX-based systems, the .py file type must be set 
to launch with the Python launcher application. When you launch a script in this manner, 
however, the command prompt window opens, shows the output of the script, and closes. 
To prevent this fly-by-window problem, you can add an input statement at the end of the 
script that pauses until the user presses the enter or return key, as follows:
input("Please press enter or return to quit the program. " )Figure 2-7  Running a Python script in a terminal window
Exercises
1. Explain the relationship between a function and its arguments.
2. The math module includes a pow function that raises a number to a given power. 
The first argument is the number, and the second argument is the exponent. Write 
a code segment that imports this function and calls it to print the values 82 and 54.
3. Explain how to display a directory of all of the functions in a given module.
4. Explain how to display help information on a particular function in a given module.
Summary
 vThe waterfall model describes the software development process in terms of several 
phases. Analysis determines what the software will do. Design determines how the 
software will accomplish its purposes. Implementation involves coding the software in 
a particular programming language. Testing and integration demonstrate that the soft-
ware does what it is intended to do as it is put together for release. Maintenance locates 
and fixes errors after release and adds new features to the software.
 vLiterals are data values that can appear in a program. They evaluate to themselves.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

60   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 2 vThe string data type is used to represent text for input and output. Strings are sequences 
of characters. String literals are enclosed in pairs of single or double quotation marks. 
Two strings can be combined by concatenation to form a new string.
 vEscape characters begin with a backslash and represent special characters such as the 
delete key and the newline.
 vA docstring is a string enclosed by triple quotation marks and provides program 
documentation.
 vComments are pieces of code that are not evaluated by the interpreter but can be read 
by programmers to obtain information about a program.
 vVariables are names that refer to values. The value of a variable is initialized and can be 
reset by an assignment statement. In Python, any variable can name any value.
 vThe int data type represents integers. The float data type represents floating-point 
numbers. The magnitude of an integer or a floating-point number is limited by the mem -
ory of the computer, as is the number’s precision in the case of floating-point numbers.
 vArithmetic operators are used to form arithmetic expressions. Operands can be 
numeric literals, variables, function calls, or other expressions.
 vThe operators are ranked in precedence. In descending order, they are exponentiation, 
negation, multiplication ( *, /, and % are the same), addition ( + and – are the same), and 
assignment. Operators with a higher precedence are evaluated before those with a lower 
precedence. Normal precedence can be overridden by parentheses.
 vMixed-mode operations involve operands of different numeric data types. They result 
in a value of the more inclusive data type.
 vThe type conversion functions can be used to convert a value of one type to a value of 
another type after input.
 vA function call consists of a function’s name and its arguments or parameters. When 
it is called, the function’s arguments are evaluated, and these values are passed to the 
function’s code for processing. When the function completes its work, it may return a 
result value to the caller.
 vPython is a strongly typed language. The interpreter checks the types of all operands 
within expressions and halts execution with an error if they are not as expected for the 
given operators.
 vA module is a set of resources, such as function definitions. Programmers access these 
resources by importing them from their modules.
 vA semantic error occurs when the computer cannot perform the requested operation, such as 
an attempt to divide by 0. Python programs with semantic errors halt with an error message.
 vA logic error occurs when a program runs to a normal termination but produces incor-
rect results.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

61Review Questions
Review Questions
1. What does a programmer do during the analysis phase of software 
development?
a. Codes the program in a particular programming language
b. Writes the algorithms for solving a problem
c. Decides what the program will do and determines its user interface
d. Tests the program to verify its correctness
2. What must a programmer use to test a program?
a. All possible sets of legitimate inputs
b. All possible sets of inputs
c. A single set of legitimate inputs
d. A reasonable set of legitimate inputs
3. What must you use to create a multi-line string?
a. A single pair of double quotation marks
b. A single pair of single quotation marks
c. A single pair of three consecutive double quotation marks
d. Embedded newline characters
4. What is used to begin an end-of-line comment?
a. / symbol
b. # symbol
c. % symbol
5. Which of the following lists of operators is ordered by decreasing  
precedence?
a. +, *, **
b. *, /, %
c. **, *, +
6. The expression 2 ** 3 ** 2  evaluates to which of the following values?
a. 64
b. 512
c. 8
7. The expression round(23.67)  evaluates to which of the following values?
a. 23
b. 23.7
c. 24.0
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

62   SOFTWARE  DEVELOPMENT, Data Types, and Expressions
CHAPTER 28. Assume that the variable name has the value 33. What is the value of name after 
the assignment name 5 name * 2 executes?
a. 35
b. 33
c. 66
9. Write an import statement that imports just the functions sqrt and log from the 
math module.
10. What is the purpose of the dir function and the help function?
Projects
In each of the projects that follow, you should write a program that contains an introduc-
tory docstring. This documentation should describe what the program will do (analysis) 
and how it will do it (design the program in the form of a pseudocode algorithm). Include 
suitable prompts for all inputs, and label all outputs appropriately. After you have coded a 
program, be sure to test it with a reasonable set of legitimate inputs.
1. The tax calculator program of the case study outputs a floating-point number 
that might show more than two digits of precision. Use the round function to 
modify the program to display at most two digits of precision in the output 
number.
2. You can calculate the surface area of a cube if you know the length of an edge. 
Write a program that takes the length of an edge (an integer) as input and prints 
the cube’s surface area as output.
3. Five Star Retro Video rents VHS tapes and DVDs to the same connoisseurs who 
like to buy LP record albums. The store rents new videos for $3.00 a night, and 
oldies for $2.00 a night. Write a program that the clerks at Five Star Retro Video 
can use to calculate the total charge for a customer’s video rentals. The program 
should prompt the user for the number of each type of video and output the total 
cost.
4. Write a program that takes the radius of a sphere (a floating-point number) as 
input and then outputs the sphere’s diameter, circumference, surface area, and 
volume.
5. An object’s momentum is its mass multiplied by its velocity. Write a program 
that accepts an object’s mass (in kilograms) and velocity (in meters per second) as 
inputs and then outputs its momentum.
6. The kinetic energy of a moving object is given by the formula KE mv12/25) ( 
where m is the object’s mass and v is its velocity. Modify the program you created 
in Project 5 so that it prints the object’s kinetic energy as well as its momentum.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

63Projects
7. Write a program that calculates and prints the number of minutes in a year.
8. Light travels at 3*108 meters per second. A light-year is the distance a light beam 
travels in one year. Write a program that calculates and displays the value of a 
light-year.
9. Write a program that takes as input a number of kilometers and prints the corre-
sponding number of nautical miles. Use the following approximations:
 vA kilometer represents 1/10,000 of the distance between the North Pole and 
the equator.
 vThere are 90 degrees, containing 60 minutes of arc each, between the North 
Pole and the equator.
 vA nautical mile is 1 minute of an arc.
10. An employee’s total weekly pay equals the hourly wage multiplied by the total 
number of regular hours plus any overtime pay. Overtime pay equals the total 
overtime hours multiplied by 1.5 times the hourly wage. Write a program that 
takes as inputs the hourly wage, total regular hours, and total overtime hours and 
displays an employee’s total weekly pay.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

CHAPTER 3
Loops and Selection 
Statements
After completing this chapter, you will be able to
Write a loop to repeat a sequence of actions a fixed 
 number of times
Write a loop to traverse the sequence of characters in a 
string
Write a loop that counts down and a loop that counts up
Write an entry-controlled loop that halts when a condition 
becomes false
Use selection statements to make choices in a program
Construct appropriate conditions for condition-controlled 
loops and selection statements
Use logical operators to construct compound Boolean 
expressions
Use a selection statement and a break statement to exit a 
loop that is not entry-controlled
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

65
Definite Iteration: The for Loop
All the programs you have studied so far in this book have consisted of short sequences 
of instructions that are executed one after the other. Even if we allowed the sequence 
of instructions to be quite long, this type of program would not be very useful. Like 
human beings, computers must be able to repeat a set of actions. They also must be able 
to select an action to perform in a particular situation. This chapter focuses on control 
 statements —statements that allow the computer to select or repeat an action.
Definite Iteration: The for Loop
We begin our study of control statements with repetition statements, also known as loops, 
which repeat an action. Each repetition of the action is known as a pass or an iteration . 
There are two types of loops—those that repeat an action a predefined number of times 
(definite iteration ) and those that perform the action until the program determines that it 
needs to stop ( indefinite iteration ). In this section, we examine Python’s for loop, the con-
trol statement that most easily supports definite iteration.
Executing a Statement a Given Number of Times
When Dr. Frankenstein’s monster came to life, the good doctor exclaimed, “It’s alive! It’s 
alive!” A computer can easily print these exclamations not just twice, but a dozen or a hun-
dred times, and you do not have to write two, a dozen, or one hundred output statements 
to accomplish this. Here is a for loop that runs the same output statement four times:
>>> for eachPass in range(4):
        print("It's alive!" , end = " ")
It's alive! It's alive! It's alive! It's alive!
This loop repeatedly calls one function—the print function. The constant 4 on the first 
line tells the loop how many times to call this function. If we want to print 10 or 100 excla-
mations, we just change the 4 to 10 or to 100. The form of this type of for loop is
for <variable> in range(<an integer expression>):
    <statement-1>
    .
    .
    <statement- n>
The first line of code in a loop is sometimes called the loop header . For now, the only rel-
evant information in the header is the integer expression, which denotes the number of 
iterations that the loop performs. The colon (:) ends the loop header. The loop body  com -
prises the statements in the remaining lines of code, below the header. These statements are 
executed in sequence on each pass through the loop. Note that the statements in the loop 
body must be indented and aligned in the same column . The IDLE shell or script window 
will automatically indent lines under a loop header, but you may see syntax errors if this 
indentation is off by even one space. It is best to indent four spaces if the indentation does 
not automatically occur when you move to the next line of code.
Now let’s explore how Python’s exponentiation operator might be implemented in a loop. 
Recall that this operator raises a number to a given power. For instance, the expression 2 ** 3  
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

66   Loops and Selection Statements
CHAPTER 3computes the value of 23, or 2 * 2 * 2. The following session uses a loop to compute an 
exponentiation for a nonnegative exponent. We use three variables to designate the number, 
the exponent, and the product. The product is initially 1. On each pass through the loop, the 
product is multiplied by the number and reset to the result. To allow us to trace this process, 
the value of the product is also printed on each pass.
>>> number = 2
>>> exponent = 3
>>> product = 1
>>> for eachPass in range(exponent):
        product = product * number
        print(product, end = " ")
2 4 8
>>> product
8
As you can see, if the exponent were 0, the loop body would not execute, and the value of 
product would remain as 1, which is the value of any number raised to the zero power.
The use of variables in the preceding example demonstrates that our exponentiation loop 
is an algorithm that solves a general class  of problems. The user of this particular loop not 
only can raise 2 to the 3rd power but also can raise any number to any nonnegative power, 
just by substituting different values for the variables number and exponent.
Count-Controlled Loops
When Python executes the type of for loop just discussed, it counts from 0 to the value of 
the header’s integer expression minus 1. On each pass through the loop, the header’s variable 
is bound to the current value of this count. The next code segment demonstrates this fact:
>>> for count in range(4):
        print(count, end = " ")
0 1 2 3
Loops that count through a range of numbers are also called count-controlled loops . The 
value of the count on each pass is often used in computations. For example, consider the 
factorial of 4, which is 1 * 2 * 3 * 542 4. A code segment to compute this value starts with a 
product of 1 and resets this variable to the result of multiplying it and the loop’s count plus 
1 on each pass, as follows:
>>> product = 1
>>> for count in range(4):
        product = product * (count + 1)
>>> product
24
Note that the value of count + 1 is used on each pass, to ensure that the numbers used are 
1 through 4 rather than 0 through 3.
To count from an explicit lower bound, the programmer can supply a second integer 
expression in the loop header. When two arguments are supplied to range, the count 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

67ranges from the first argument to the second argument minus 1. The next code segment 
uses this variation to simplify the code in the loop body:
>>> product = 1
>>> for count in range(1, 5):
        product = product * count
>>> product
24
The only thing in this version to be careful about is the second argument of range, which 
should specify an integer greater by 1 than the desired upper bound of the count. Here is 
the form of this version of the for loop:
for <variable> in range(<lower bound>, <upper bound + 1>):
    <loop body>
Accumulating a single result value from a series of values is a common operation in com-
puting. Here is an example of a summation , which accumulates the sum of a sequence of 
numbers from a lower bound through an upper bound:
>>> lower = int(input("Enter the lower bound: " ))
Enter the lower bound:  1
>>> upper = int(input("Enter the upper bound: " ))
Enter the upper bound:  10
>>> theSum = 0
>>> for number in range(lower, upper + 1):
        theSum = theSum + number
>>> theSum
55
Note that we use the variable theSum rather than sum to accumulate the sum of the numbers 
in this code. Since sum is the name of a built-in Python function, it’s a good idea to avoid 
using such names for other purposes in our code.
Augmented Assignment
Expressions such as x=x+1 or x=x+2 occur so frequently in loops that Python 
includes abbreviated forms for them. The assignment symbol can be combined with the 
arithmetic and concatenation operators to provide augmented assignment operations . 
Following are several examples:
a = 17
s = "hi"
a += 3         # Equivalent to a = a + 3
a -= 3         # Equivalent to a = a - 3
a *= 3         # Equivalent to a = a * 3
a /= 3         # Equivalent to a = a / 3
a %= 3         # Equivalent to a = a % 3
s += " there"   # Equivalent to s = s + " there"
All these examples have the format
<variable> <operator> = <expression>
Definite Iteration: The for Loop
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

68   Loops and Selection Statements
CHAPTER 3which is equivalent to
<variable> = <variable> <operator> <expression>
Note that there is no space between <operator>  and =. The augmented assignment opera-
tions and the standard assignment operations have the same precedence.
Loop Errors: Off-by-One Error
The for loop is not only easy to write but also fairly easy to write correctly. Once we get the 
syntax correct, we need to be concerned about only one other possible error: The loop fails 
to perform the expected number of iterations. Because this number is typically off by one, 
the error is called an off-by-one error . For the most part, off-by-one errors result when 
the programmer incorrectly specifies the upper bound of the loop. The programmer might 
intend the following loop to count from 1 through 4, but it counts from 1 through 3:
# Count from 1 through 4, we think
>>> for count in range(1,4):
    print(count)
1
2
3
Note that this is not a syntax error, but rather a logic error. Unlike syntax errors, logic 
errors are not detected by the Python interpreter, but only by the eyes of a programmer 
who carefully inspects a program’s output.
Traversing the Contents of a Data Sequence
Although we have been using the for loop as a simple count-controlled loop, the loop itself 
visits each number in a sequence of numbers generated by the range function. The next 
code segment shows what these sequences look like:
>>> list(range(4))
[0, 1, 2, 3]
>>> list(range(l, 5))
[1, 2, 3, 4]
In this example, the sequence of numbers generated by the function range is fed to Python’s 
list function, which returns a special type of sequence called a list. Strings are also 
sequences of characters. The values contained in any sequence can be visited by running a 
for loop, as follows:
for <variable> in <sequence>:
    <do something with variable>
On each pass through the loop, the variable is bound to or assigned the next value in the 
sequence, starting with the first one and ending with the last one. The following code 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

69segment traverses or visits all the elements in two sequences and prints the values con-
tained in them, separated by spaces:
>>> for number in [6, 4, 8]:
        print(number, end = " ")
6 4 8
>>> for character in "Hi there!" :
        print(character, end = " ")
H i  t h e r e !
Specifying the Steps in the Range
The count-controlled loops we have seen thus far count through consecutive numbers in a 
series. However, in some programs we might want a loop to skip some numbers, perhaps 
visiting every other one or every third one. A variant of Python’s range function expects 
a third argument that allows you to nicely skip some numbers. The third argument speci-
fies a step value , or the interval between the numbers used in the range, as shown in the 
examples that follow:
>>> list(range(1, 6, 1))   # Same as using two arguments
[1, 2, 3, 4, 5] 
>>> list(range(1, 6, 2))   # Use every other number
[1, 3, 5] 
>>> list(range(1, 6, 3))   # Use every third number
[1, 4]
Now, suppose you had to compute the sum of the even numbers between 1 and 10. Here is 
the code that solves this problem:
>>> theSum = 0
>>> for count in range(2, 11, 2):
        theSum += count
>>> theSum
30
Loops That Count Down
All of our loops until now have counted up from a lower bound to an upper bound. Once in 
a while, a problem calls for counting in the opposite direction, from the upper bound down 
to the lower bound. For example, when the top-10 singles tunes are released, they might be 
presented in order from lowest (10th) to highest (1st) rank. In the next session, a loop dis-
plays the count from 10 down to 1 to show how this would be done:
>>> for count in range(10, 0, -1):
        print(count, end = " ")
10 9 8 7 6 5 4 3 2 1
>>> list(range(10, 0, –1))
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Definite Iteration: The for Loop
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

70   Loops and Selection Statements
CHAPTER 3When the step argument is a negative number, the range function generates a sequence 
of numbers from the first argument down to the second argument plus 1. Thus, in this 
case, the first argument should express the upper bound, and the second argument should 
express the lower bound minus 1.
Exercises
1. Write the outputs of the following loops:
a. for count in range(5):
            print(count + 1, end = " ")
b. for count in range(1, 4):
            print(count, end = " ")
c. for count in range(1, 6, 2):
            print(count, end = " ")
d. for count in range(6, 1, –1):
            print(count, end = " ")
2. Write a loop that prints your name 100 times. Each output should begin on a  
new line.
3. Explain the role of the variable in the header of a for loop.
4. Write a loop that prints the first 128 ASCII values followed by the corresponding 
characters (see the section on characters in Chapter 2). Be aware that most of the 
ASCII values in the range “0..31” belong to special control characters with no stan-
dard print representation, so you might see strange symbols in the output for these 
values.
5. Assume that the variable teststring  refers to a string. Write a loop that prints 
each character in this string, followed by its ASCII value.
Formatting Text for Output
Before turning to our next case study, we need to examine more closely the format of text 
for output. Many data-processing applications require output that has a tabular format , 
like that used in spreadsheets or tables of numeric data. In this format, numbers and 
other information are aligned in columns that can be either left-justified or right-justified. 
A column of data is left-justified if its values are vertically aligned beginning with their 
leftmost characters. A column of data is right-justified if its values are vertically aligned 
beginning with their rightmost characters. To maintain the margins between columns of 
data, left-justification requires the addition of spaces to the right of the datum, whereas 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

71Formatting Text for Output
right-justification requires adding spaces to the left of the datum. A column of data is cen-
tered if there are an equal number of spaces on either side of the data within that column.
The total number of data characters and additional spaces for a given datum in a formatted 
string is called its field width .
The print function automatically begins printing an output datum in the first available 
column. The next example, which displays the exponents 7 through 10 and the values of 107 
through 1010, shows the format of two columns produced by the print function:
>>> for exponent in range(7, 11):
        print(exponent, 10 ** exponent)
7 10000000
8 100000000
9 1000000000
10 10000000000
Note that when the exponent reaches 10, the output of the second column shifts over by a 
space and looks ragged. The output would look neater if the left column were left-justified 
and the right column were right-justified. When we format floating-point numbers for 
output, we often would like to specify the number of digits of precision to be displayed as 
well as the field width. This is especially important when displaying financial data in which 
exactly two digits of precision are required.
Python includes a general formatting mechanism that allows the programmer to specify 
field widths for different types of data. The next session shows how to right-justify and 
 left-justify the string "four" within a field width of 6:
>>> "%6s" % "four" # Right justify
'  four'
>>> "%-6s" % "four" # Left justify
'four '
The first line of code right-justifies the string by padding it with two spaces to its left. The 
next line of code left-justifies by placing two spaces to the string’s right.
The simplest form of this operation is the following:
<format string> % <datum>
This version contains a format string , the format operator %, and a single data value to 
be formatted. The format string can contain string data and other information about the 
format of the datum. To format the string data value in our example, we used the nota-
tion %<field width>s  in the format string. When the field width is positive, the datum is 
right-justified; when the field width is negative, you get left-justification. If the field width is 
less than or equal to the datum’s print length in characters, no justification is added. The % 
operator works with this information to build and return a formatted string.
To format integers , you use the letter d instead of s. To format a sequence of data values, you 
construct a format string that includes a format code for each datum and place the data values 
in a tuple following the % operator. The form of the second version of this operation follows:
<format string> % (<datum–1>, ..., <datum– n>)
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

72   Loops and Selection Statements
CHAPTER 3Armed with the format operation, our powers of 10 loop can now display the numbers in 
nicely aligned columns. The first column is left-justified in a field width of 3, and the second 
column is right-justified in a field width of 12.
>>> for exponent in range(7, 11):
        print("%-3d%12d"  % (exponent, 10 ** exponent))
7      10000000
8     100000000
9    1000000000
10  10000000000
The format information for a data value of type float has the form 
%<field width>.<precision>f  
where .<precision>  is optional. The next session shows the output of a floating-point 
number without, and then with, a format string:
>>> salary = 100.00
>>> print("Your salary is $"  + str(salary))
Your salary is $100.0
>>> print("Your salary is $%0.2f"  % salary)
Your salary is $100.00
Here is another, minimal, example of the use of a format string, which says to use a field 
width of 6 and a precision of 3 to format the float value 3.14:
>>> "%6.3f" % 3.14
' 3.140'
Note that Python adds a digit of precision to the string and pads it with a space to the left to 
achieve the field width of 6. This width includes the place occupied by the decimal point.
Exercises
1. Assume that the variable amount refers to 24.325. Write the outputs of the following 
statements:
a. print("Your salary is $%0.2f"  % amount)
b. print("The area is %0.1f"  % amount)
c. print("%7f" % amount)
2. Write a code segment that displays the values of the integers x, y, and z on a single 
line, such that each value is right-justified with a field width of 6.
3. Write a format operation that builds a string for the float variable amount that has 
exactly two digits of precision and a field width of zero.
4. Write a loop that outputs the numbers in a list named salaries. The outputs should be 
formatted in a column that is right-justified, with a field width of 12 and a precision of 2.
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

73Formatting Text for Output
CASE STUDY: An Investment Report
It has been said that compound interest is the eighth wonder of the world. Our next 
case study, which computes an investment report, shows why.
Request
Write a program that computes an investment report.
Analysis
The inputs to this program are the following:
 vAn initial amount to be invested (a floating-point number)
 vA period of years (an integer)
 vAn interest rate (a percentage expressed as an integer)
The program uses a simplified form of compound interest, in which the interest is 
computed once each year and added to the total amount invested. The output of 
the program is a report in tabular form that shows, for each year in the term of the 
investment, the year number, the initial balance in the account for that year, the inter -
est earned for that year, and the ending balance for that year. The columns of the 
table are suitably labeled with a header in the first row. Following the output of the 
table, the program prints the total amount of the investment balance and the total 
amount of interest earned for the period. The proposed user interface is shown in 
Figure 3-1.
Figure 3-1  The user interface for the investment report programEnter the investment amount: 10000.00
Enter the number of years: 5Enter the rate as a %: 5Year  Starting balance  Interest  Ending balance
   1          10000.00    500.00        10500.00
   2          10500.00    525.00        11025.00
   3          11025.00    551.25        11576.25
   4          11576.25    578.81        12155.06
   5          12155.06    607.75        12762.82
Ending balance: $12762.82
Total interest earned: $2762.82(continues )
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

74   Loops and Selection Statements
CHAPTER 3Design
The four principal parts of the program perform the following tasks:
1. Receive the user’s inputs and initialize data.
2. Display the table’s header.
3. Compute the results for each year, and display them as a row in the table.
4. Display the totals.
The third part of the program, which computes and displays the results, is a loop. The 
following is a slightly simplified version of the pseudocode for the program, without 
the details related to formatting the outputs:
Input the starting balance, number of years, and interest rate
Set the total interest to 0.0
Print the table's heading
For each year
     compute the interest
     compute the ending balance
     print the year, starting balance, interest, and ending balance
     update the starting balance
     update the total interest
print the ending balance and the total interest
Note that starting balance  refers to the original input balance and also to the balance 
that begins each year of the term. Ignoring the details of the output at this point allows 
us to focus on getting the computations correct. We can translate this pseudocode to 
a Python program to check our computations. A rough draft of a program is called a 
 prototype . Once we are confident that the prototype is producing the correct numbers, 
we can return to the design and work out the details of formatting the outputs.
The format of the outputs is guided by the requirement that they be aligned nicely in 
columns. We use a format string to right-justify all of the numbers on each row of out-
put. We also use a format string for the string labels in the table’s header. After some 
trial and error, we come up with field widths of 4, 18, 10, and 16 for the year, start-
ing balance, interest, and ending balance, respectively. We can also use these widths 
in the format string for the header.
Implementation (Coding)
The code for this program shows each of the major parts described in the design, 
set off by end-of-line comments. Note the use of the many variables to track the 
(continues )(continued  )
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

75Formatting Text for Output
various amounts of money used by the program. Wisely, we have chosen names for 
these variables that clearly describe their purpose. The format strings in the print 
statements are rather complex, but we have made an effort to format them so the 
information they contain is still fairly readable.
"""
Program: investment.py
Author: Ken
Compute an investment report.
1. The inputs are
     starting investment amount
     number of years
     interest rate (an integer percent)
2. The report is displayed in tabular form with a header.
3. Computations and outputs:
     for each year
        compute the interest and add it to the investment  
        print a formatted row of results for that year
4. The ending investment and interest earned are also 
   displayed.
"""
# Accept the inputs
startBalance = float(input("Enter the investment amount: " ))
years = int(input("Enter the number of years: " ))
rate = int(input("Enter the rate as a %: " ))
# Convert the rate to a decimal number
rate = rate / 100
# Initialize the accumulator for the interest
totalInterest = 0.0
# Display the header for the table
print("%4s%18s%10s%16s"  % \
    ("Year", "Starting balance" ,
     "Interest" , "Ending balance" ))
# Compute and display the results for each year
for year in range(1, years + 1):
    interest = startBalance * rate
    endBalance = startBalance + interest
    print("%4d%18.2f%10.2f%16.2f"  % \
        (year, startBalance, interest, endBalance))
    startBalance = endBalance
    totalInterest += interest
(continues )(continued  )
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

76   Loops and Selection Statements
CHAPTER 3# Display the totals for the period
print("Ending balance: $%0.2f"  % endBalance)
 print("Total interest earned: $%0.2f"  % totalInterest)
Testing
When testing a program that contains a loop, we should focus first on the input 
that determines the number of iterations. In our program, this value is the number 
of years. We enter a value that yields the smallest possible number of iterations, 
then increase this number by 1, then use a slightly larger number, such as 5, and 
finally we use a number close to the maximum expected, such as 50 (in our problem 
domain, probably the largest realistic period of an investment). The values of the 
other inputs, such as the investment amount and the rate in our program, should 
be reasonably small and stay fixed for this phase of the testing. If the program pro -
duces correct outputs for all of these inputs, we can be confident that the loop is 
working correctly.
In the next phase of testing, we examine the effects of the other inputs on the 
results, including their format. We know that the other two inputs to our programs, 
the investment and the rate, already produce correct results for small values. A rea -
sonable strategy might be to test a large investment amount with the smallest and 
largest number of years and a small rate, and then with the largest number of years 
and the largest reasonable rate. Table 3-1 organizes these sets of test data for the 
program.(continued  )
Investment Years Rate
100.00 1 5
100.00 2 5
100.00 5 5
100.00 50 5
10000.00 1 5
10000.00 50 5
10000.00 50 20
Table 3-1  The data sets for testing the investment program
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

77
Selection: if and if-else Statements
Selection: if and if-else Statements
We have seen that computers can plow through long sequences of instructions and that 
they can do so repeatedly. However, not all problems can be solved in this manner. In some 
cases, instead of moving straight ahead to execute the next instruction, the computer might 
be faced with two alternative courses of action. The computer must pause to examine or 
test a condition , which expresses a hypothesis about the state of its world at that point in 
time. If the condition is true, the computer executes the first alternative action and skips the 
second alternative. If the condition is false, the computer skips the first alternative action 
and executes the second alternative.
In other words, instead of moving blindly ahead, the computer exercises some intelligence 
by responding to conditions in its environment. In this section, we explore several types of 
selection statements , or control statements, that allow a computer to make choices. But 
first, we need to examine how a computer can test conditions.
The Boolean Type, Comparisons, and Boolean Expressions
Before you can test conditions in a Python program, you need to understand the Boolean 
data type , which is named for the nineteenth century British mathematician George Boole. 
The Boolean data type consists of only two data values—true and false. In Python, Boolean 
literals can be written in several ways, but most programmers prefer to use the standard 
values True and False.
Simple Boolean expressions  consist of the Boolean values True or False, variables bound 
to those values, function calls that return Boolean values, or comparisons. The condition 
in a selection statement often takes the form of a comparison. For example, you might 
 compare value A to value B to see which one is greater. The result of the comparison is 
a Boolean value. It is either true or false that value A is greater than value B. To write 
 expressions that make comparisons, you have to be familiar with Python’s comparison 
operators, which are listed in Table 3-2.
Comparison Operator Meaning
== Equals
!= Not equals
< Less than
> Greater than
<= Less than or equal
>= Greater than or equal
Table 3-2  The comparison operators
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203

78   Loops and Selection Statements
CHAPTER 3The following session shows some example comparisons and their values:
>>> 4 == 4
True
>>> 4 != 4
False
>>> 4 < 5
True
>>> 4 >= 3
True
>>> "A" < "B"
True
Note that == means equals, whereas = means assignment. As you learned in Chapter 2, 
when evaluating expressions in Python, you need to be aware of precedence—that is, the 
order in which operators are applied in complex expressions. The comparison operators are 
applied after addition but before assignment.
if-else Statements
The if-else statement  is the most common type of selection statement. It is also called a 
two-way selection statement , because it directs the computer to make a choice between 
two alternative courses of action.
The if-else statement is often used to check inputs for errors and to respond with error 
messages if necessary. The alternative is to go ahead and perform the computation if the 
inputs are valid.
For example, suppose a program inputs the area of a circle and computes and outputs its 
radius. Legitimate inputs for this program would be positive numbers. But, by mistake, the 
user could still enter a zero or a negative number. Because the program has no choice but to 
use this value to compute the radius, it might crash (stop running) or produce a meaning-
less output. The next code segment shows how to use an if-else statement to locate (trap) 
this error and respond to it:
import math
area = float(input("Enter the area: " ))
if area > 0:
    radius = math’s(area / math.pi)
    print("The radius is" , radius)
else:
    print("Error: the area must be a positive number" )
Here is the Python syntax for the if-else statement:
if <condition>:
    <sequence of statements–1>
else:
    <sequence of statements–2>
The condition in the if-else statement must be a Boolean expression—that is, an 
expression that evaluates to either true or false. The two possible actions each consist of 
Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.Copyright 2019 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part.  WCN 02-200-203


[Note: PDF has 498 pages, only first 100 pages extracted]